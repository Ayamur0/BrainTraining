% \graphic{riddleScene}{Szenenaufbau für Rätsel}
% Text für das Design der Lernspiel szenen von der ersten bis zur letzten.
% Liste mit allen Szenen machen, von den Grundrechenarten bis zum endscreen
\subsection{Szene - Menü}

%TODO Variablen in den Skripten Checken
\subsubsection{Menü - Design}
\graphic{menuLearning}{Auswahl der Level}

In der Abbildung 5.15 ist die Auswahl der sechs unterschiedlichen Level zu sehen. Die Szene besteht aus einem Zurück-Button und sechs weiteren für die Lernspiele. Mit dem zurück Button kommt man wieder in das Hauptmenü. Die restlichen Buttons leiten den Nutzer ein Menü weiter. In dem nächsten Menü werden die Alternativen und die Schwierigkeiten des Spiels festgelegt. Die Buttons wurden im Programm \textit{Inkscape vector graphics} erstellt. Damit die beiden Teile des Projektes zusammenpassen, wurde ein einheitliches Design überlegt. Dieses unterscheidet sich in den Farben und in den Buttons. Der Hintergrung, die Art der Buttons und die Schrifftart sind die gleichen. So das das Kind anhand der Farben einen Unterschied in den Abschnitten Rätseln und Lernspiele erkennen kann. In dieser Szene wurde für jeden Button ein PNG entworfen. Wie dies im Programm \textit{Inkscape} aussieht ist in der Abbildung 5.16 zu sehen.\\
\graphic{InkscapeButtonGreen}{Button-Design} 
Der Button besteht aus mehreren Objekten, welche in Abbildung 5.17 zu sehen sind. Für den Hintergrund des Buttons wurden drei Rechtecke erzeugt, ein weißes, ein dunkelgüßnes und ein hellgrünes. Diese werden immer kleiner und anschließend übereinander gelegt. Von allen Rechtecken werden die Kanten abgerundet. Als letztes werden noch zwei Textfelder eingefügt. Jedes der Textfelder ist unterschiedlich gestaltet, so dass am Ende die gewünschte Schrift rauskommt. 
\graphic{InkscapeButtonSingleTiles}{Button einzelteile}
Nachdem das Design für die einzelnen Buttons fertig sind, werden diese in Unity auf die \textit{Image} Komponente des Buttons gezogen. Dies ist in der Abbildung 5.18 zu sehen.
In dieser Abbildung, markiert ein grüner Pfeil die Stelle ab der das Image des Buttons ausgewählt wird.
\graphic{buttonImgChange}{Button Image ändern}

\subsubsection{Menü - Skript}

In diesem Abschnitt wird das Skript erklärt, welches die Auswahl der Level verwaltet.
Das Skript wird hierfür in kleine Teile zerlegt und anschließend erklärt.\\

\begin{lstlisting}[language=csh, caption={MenuPickLevel.cs Klasse Menü Imports}]
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using System;
\end{lstlisting}

Zu Beginn des Skriptes werden verschiedene Bibliotheken eingebunden. Diese werden für die Skripte in den nachfolgenden Abschnitten sehr ähnlich sein oder sich gar nicht unterscheiden. Mithilfe des Befehls \textit{using} werden Bibliotheken von C\# und Unity importiert. Diese werden benötigt, um zum Beispiel Arrays zu erstellen und verwalten zu können. Mit den Bibliotheken von Unity kann man auf die Objekte in Unity per Skript zugreifen und diese verwalten oder bearbeiten.\\

\begin{lstlisting}[language=csh, caption={MenuPickLevel.cs Klasse Menü Variablen}]
public class MenuPickLevel : MonoBehaviour
{
	public Button[] buttonsMenu = new Button[7];

	public enum LvlType{
		BACK = 1,
		QUANTITIES = 2,
		MATHOPERATIONS = 3,
		TRIANGLE = 4,
		LIGHTNIGVIEW = 5,
		PATTER = 6,
		MIXEDWORDS = 7
	}

	public static int loadButtonsPrefab = 0;
\end{lstlisting}

Nachdem alle notwendigen Bibliotheken eingebunden wurden, wird die Klasse deklariert. Die Klasse bekommt hinten \textit{MonoBehaviour} angehängt, dies ermöglicht unteranderem Funktionen wie \textit{void start()} und \textit{void() update} zu nutzen. Wenn ein Skript diese Funktionen nicht benötigt, weil es zum Beispiel nur etwas ausrechen muss, so kann das \textit{MonoBehaviour} dahinter weggelassen werden.\\
In den darauf folgenden Zeilen werden die Variablen deklariert die für das Skript notwendig sind. Zuerst werden die Buttons deklariert. Der auskommentierte Code, welcher in der Abbildung für eine bessere Übersichtlichkeit nicht dargestellt wird, stellt eine alternative Lösung dar. In Unity können Buttons in das Skript eingefügt werden, welches man in Abbildung 5.16 sehen kann. Dadurch können wir im Code dann auf das Objekt des jeweiligen Buttons zugreifen und mit diesen arbeiten. Es gibt zwei Möglichkeiten mehrere Buttons zu implementieren. Entweder man deklariert die anzahl an Buttons selbst oder man nutzt ein Array dafür. Beides ist in den folgenden Abbildungen zu sehen.
\graphic{buttonZuweisen}{Buttons in Unity einzeln zuweisen}
\graphic{buttonsIntoArray}{Buttons in Unity in Array einfügen}
In C\# gibt es standardmäßig nicht die Möglchkeit ein \textit{Const Array} zu erstellen. Für jeden Button wird in diesem Skript eine Konstante benötigt, denn diese soll dem nachfolgenden Skript weiterleiten welcher Button gedrückt wurde. Dies ist wichtig, da die Level unterschiedliche Varianten und Schwierikeitsgrade beinhalten und dementsprechend unterschiedliche Buttons angezeigt werden. Um ein Array zu deklarieren, welches ähnlich zu einer Konstanten funktioniert, kann ein Array welches \textit{readonly} ist oder eine Enumeration verwendet werden. Eine Enumeration ist eine Reihe benannter Konstanten, das heißt alle Komma die von Hand einzeln erzeugt wurden, können in die Enumeration eingespeichert werden. Da diese Lösung weniger Code benötigt und für mehrere Buttons effektiver ist, wurde diese Möglichkeit auch umgesetzt. In der Menü-Szene sind beide Möglichkeiten im Code geschrieben, aber die Umsetzung alle Buttons und Konstanten einzeln zu deklarieren wurde auskommentiert.\\
Als letztes wird eine statische Variable deklariert, welche später den Wert einer Konstanten zugewiesen bekommt. In der nächsten Szene kann dann auf diese zugegriffen werden und somit ist dem nachfolgenden Skript dann klar, welche Buttons für die nächste Szene geladen werden müssen. In Unity gibt es unterschiedliche Möglichkeiten, um Werte zwischen Skripten transferieren zu können. Einmal wären das static Variablen. Unity selbst bietet aber auch die Möglichkeit einen Wert in eine Varibale in einem file zu speichern, dafür wird der \textit{PlayerPrefs.setInt/String/Float("variablen name", variablen wert);} verwendet. Diese Variante wird in diesem Skript nicht verwendet, da nur die Information aus dem alten Skript benötigt wird und diese nur für diese beiden Skripte notwendig ist. Wenn die Information für mehrere Skripte notwendig wäre, könnte man diese durch den \textit{PlayerPrefs} Befehl speichern.\\

\begin{lstlisting}[language=csh, caption={MenuPickLevel.cs Klasse Menü Start-Funktion}]
	void Start()
	{
		Debug.Log(buttonsMenu.Length);
		for (int i = 0; i < buttonsMenu.Length; i++){
			int temp = i;
			buttonsMenu[temp].onClick.AddListener(() => loadAdvancedOptions((LvlType)temp + 1));
		}
	}
\end{lstlisting}
In der \textit{Start} Funktion werden jedem Button ein \textit{Listener} hinzugefügt. Es gibt auch hier wieder die Möglichkeit dies für jeden Button einzeln zu erledigen oder mithilfe eines Arrays und der Enumeration dies in einer \textit{FOR}-Schleife durchzuführen.\\
Die Schleife startet bei 0 und läuft bis sie durch alle Buttons durch iteriert hat. Dabei kann es zu einem Problem kommen, das die Variable i gefangen nimmt. Das bedeutet, dass egal welcher Button gedrückt wird die letzte Möglichkeit der Iteration geladen wird. Auf das Projekt übertragen würde das bedeuten, dass jeder Button zum selben Level führt. Um dieses Problem zu verhindern, wird eine temporäre Variable \textit{temp} deklariert, die den Wert von i zugewiesen bekommt. Jetzt wird jedem Button aus dem Array an der Position \textit{temp} ein \textit{onClick-Event} hinzugefügt, welches die Möglichkeit bietet, wenn der Button gedrückt wurde etwas oder eine Funktion auszuführen. In diesem Fall wird die \textit{AddLister Funktion} aufgerufen. Mit den leeren Klammern und dem Pfeil (() =>) wird eine Funktion deklariert, die ausgeführt wird, wenn der Button gedrückt wurde. In diesem Fall wird die Funktion, die Szene mit den jeweiligen Varianzen an Modi und Schwierigkeiten lädt aufgerufen. Hierbei wird der Integer Wert aus \textit{temp} verwendet. Dieser muss in den Enumerationstypen umgewandelt werden, diese Umwandlung wird casten genannt. Dabei wird vor die Variable der gewünschte Typ in Klammern geschrieben (LvlTyp). Danach wird die Variable \textit{temp + 1} verwendet, das hat den Grund, dass später mit dieser Variablen gearbeitet wird und das Skript für das erweiterte Menü diese Variable ab der Stelle eins bearbeitet. In einer früheren Version gab es in dieser Szene einen Menü-Button, der die Stelle null belegt hat und später entfernt wurde. Die Skripte funktionieren aber ohne diesen Button ohne Probleme, deshalb wurde es nicht angepasst.\\

\begin{lstlisting}[language=csh, caption={MenuPickLevel.cs Klasse Menü loadAdvancedOptions- Funktion}]
	public void loadAdvancedOptions(LvlType choice){
		switch (choice)
		{
			case LvlType.BACK:
				loadButtonsPrefab = (int)LvlType.BACK;
				SceneManager.LoadScene("MainMenu");
				break;
			case LvlType.QUANTITIES:
				loadButtonsPrefab = (int)LvlType.QUANTITIES;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.MATHOPERATIONS:
				loadButtonsPrefab = (int)LvlType.MATHOPERATIONS;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.TRIANGLE:
				loadButtonsPrefab = (int)LvlType.TRIANGLE;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.LIGHTNIGVIEW:
				loadButtonsPrefab = (int)LvlType.LIGHTNIGVIEW;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.PATTER:
				loadButtonsPrefab = (int)LvlType.PATTER;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.MIXEDWORDS:
				loadButtonsPrefab = (int)LvlType.MIXEDWORDS;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;

			default:
				break;
		}
	}
\end{lstlisting}

In Zeile 46 beginnt die Funktion, die die nächste Szene lädt. Die Szene unterscheidet mit einem \textit{switch-case}-Statement welcher Button gedrückt wurde und speichert den passenden Wert in die static Variable ein. Der Wert aus der Enumeration wird hierbei in einen Integer Wert umgewandelt. Danach wird die nächste Szene geladen. Der Zurück-Button leitet den Nutzer zum Hauptmenü zurück und die anderen Buttons laden die neue Szene, also das erweiterte Menü. Das erweiterte Menü ist für alle Buttons die gleiche Szene, da diese sich nur in der Anzahl an Auswahlmöglichkeiten unterscheidet. Dies wird aber im nächsten Abschnitt genauer erläutert.\\
In dieser Szene ist noch anzumerken, dass es einen Fehler bei den Konstanten gab, so dass im erweiterten Menü zweimal dasselbe Level geladen wurde. Wie dieser genau zustande kam und wie er gelöst wurde wird im nächsten Abschnitt genauer erläutert.

\subsection{Szene - Erweitertes Menü}
\subsubsection{Erweitertes Menü - Design}
In diesem Abschnitt, wird das Design des erweiterten Menüs erklärt. In diesem Menü gibt es wieder einen Zurück-Button, der in das vorherige Menü zurückleitet. Auf der linken Seite des Menüs werden die alternativen Spielmodi angezeigt und auf der rechten Seite die Schwierigkeitsgraden. Zu sehen ist dies in der Abbildung 5.20. Die Alternativen sind nicht für jedes Level vorhanden oder gleich, wenn es keine zur Auswahl gibt, ist die linke Hälfte  leer. Für die beiden Seiten wurden auch wieder mehrere Button-Designs angefertigt.
\graphic{basicOperatorsAdvanced}{Auswahl der einzelnen Optionen eines Levels}
Um das ausgewählte Spiel starten zu können, muss auf beiden Seiten eine Option gewählt werden. Solange nicht auf beiden Seiten ein Button ausgewählt wurde, ist der Start-Button deaktiviert. Wenn ein Button auf einer Seite ausgewählt, wurde wird dieser keaktiviert und kann nicht wiederholt ausgewählt werden. Sobald eine andere Alternative ausgewält wird, wird diese deaktiviert und die andere wieder aktiviert. So wird verhindert, dass nie mehr als eine möglichkeit aktiviert sein kann. Wenn ein Level ohne Alternativenwahl ausgewählt wurde, muss nur eine Schwierigkeit ausgewählt werden, um das Spiel zu starten. In der Abbildung 5.21 ist eine Auswahl zu sehen. Der Start-Button ist hier noch deaktiviert, weil keine Schwierigkeit gewählt wurde. 
\graphic{basicOperatorsAdvancedSingleChoice}{Einzelne Auswahl}
Nachdem auf jeder Seite ein Button gewählt wurde, ist der Start-Button nicht mehr deaktiviert und der Spieler kann das Spiel starten.
\graphic{basicOperatorsAdvancedFinish}{Auswahlbedingung um das Level zu laden}
\subsubsection{Erweitertes Menü - Skript}
In diesem Abschnitt, wird das Skript erklärt. Da die Imports die selben sind, werden diese nicht erneut erklärt.
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs Variablendeklaration}]
public class MenuPickLevelAdvanced : MonoBehaviour
{

	//Buttons
	public Button back;
	public Button start;

	public List <Button> leftSideList = new List<Button>();
	private List<Button> rightSideList = new List<Button>();

	public GameObject buttonPref;
	public GameObject spawnerLeft;
	public GameObject spawnerRight;
	private GameObject spawnedObject;

	public Sprite[] quantitiesModes = new Sprite[2];
	public Sprite[] mathModes = new Sprite[4];
	public Sprite[] difficulty = new Sprite[3];

	public static int maxNumberStatic = 0;
	public static int lvlAmmountStatic = 0;
	public static int fourChoices = 0;
	public static int wallSize = 0;

	private int loadButtonsNumber = 0;
	private bool leftSide = false;
	private bool rightSide = false;
	private Vector3 scaleSize = new Vector3 (1.0f, 1.0f, 1.0f);
\end{lstlisting}
%TODO Variablen in den Skripten Checken
Die Klasse beinhaltet mehr Variablen und Objekte. In diesem Fall wurden zwei Buttons deklariert, da diese in der Szene immer vorkommen. Die Buttons für die linke und rechte Seite werden in Listen gespeichert, also nicht in Unity festgelegt. Um mehrere Buttons per Skript zu spawnen, werden nach den Listen Objekte mit einem Prefab eines Buttons und den beiden bereichen hier \textit{spawnerLeft} und \textit{spawnerRight} deklariert. Diese drei sind public, da sie in Unity den Objekten zugewiesen werden. Das Objekt \textit{spawnedObject} wird hier deklariert und kann private bleiben, da es nur im Skript verwenden wird. Der Gebrauch wird in den unteren Funktionen erklärt.\\
Da die Buttons für die Alternativen und die Schwierigkeit unterschiedlich aussehen, werden zunächst drei \textit{Sprite Arrays} erzeugt, in welche Bilder der vergefertigten Buttons gezogen werden. So kann auf die Bilder in der richtigen Reihnfolge später zugegriffen und anschließend können diese verwendet werden.\\
Als nächstes werden static Variablen benötigt mit welchen die Werte gespeichert werden mit denen das Level initialisiert wird. Die \textit{maxNumberStatic} speichert die Zahl ein die später maximal zufällig generiert werden kann. Je nach Schwierigkeit ist diese größer oder kleiner. Die \textit{lvlAmmountStatic} legt fest, wie viele Level das Kind spielen muss bevor er dieses abgeschlossen hat. Die \textit{fourChoices Variable} speichert die linke Auswahl ein. Der Name ist ein wenig irreführend, da es nur einspeichern soll welcher Button links ausgewählt wurde. Das sind die Möglichkeiten im Spiel "größer, kleiner, gleich"\ oder bei den "Grundrechenarten"\. Also speichert diese die Zahlen von eins bis vier ein. Die \textit{wallSize} ist nur für die Rechenmauer notwendig, je nach der Schwierigkeit, ist die Mauer unten drei, vier oder fünf Steine breit.\\
Als letztes werden noch vier private Variablen benötigt. Der Variable \textit{loadButtonsNumber} wird die static Variable aus der vorherigen Szene zugewiesen. Die beiden Boolean Variablen werden benötigt, um die linke und rechte Seite der Buttons zu überprüfen. Da die Buttons, wenn sie in einem Canvas erzeugt werden, kleinerskaliert werden müssen diese mithilfe des Vektors wieder auf die Originalgröße skaliert werden.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs Start-Funktion}]
	void Start()
	{
		loadButtonsNumber = MenuPickLevel.loadButtonsPrefab;
		back.onClick.AddListener(() => GoBack());
		start.onClick.AddListener(() => LoadGame());
		SpawnButtonsRight();
		if(loadButtonsNumber == 2 || loadButtonsNumber == 3){
			SpawnButtonsLeft();
		}
		else{
			leftSide = true;
		}
	}
\end{lstlisting}
Die Start-Funktion wird sobald die Szene geladen. Diese speichert den Wert der static Variablen aus dem vorherigen Skript in eine Variable. Da die Variable public war, kann mit dem Namen des Skriptes und dem Namen der Variablen auf diese zugegriffen werden.
Danach bekommen die Buttons, um zurückzugehen und um das Level zu starten, ihre Funktion zugewiesen. Da die Buttons auf der rechten seite immer gleich sind, werden diese als nächstes erzeugt, dies wird in der Funktion \textit{SpawnButtonsRight} erledigt. Danach muss für die linke Seite überprüft werden, ob es überhaupt Alternativen gibt, wenn dies nicht der Fall wäre, würde der Boolean für die linke Seite auf \textit{true} gesetzt werden. Um zu überprüfen welche Alterantiven benötigt werden, wird die \textit{loadButtonsNumber} überprüft. Wenn diese den Wert zwei oder drei zugewiesen bekam, entspricht dies dem Spiel  größer, kleiner, gleich oder Grundrechenarten. Wenn eine dieser beiden Möglichkeiten besteht, werden die Buttons auf der linken Seite erzeugt.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs Update-Funktion}]
	void Update(){
		if(!leftSide || !rightSide){
			start.interactable = false;
		}
		if(leftSide && rightSide){
			start.interactable = true;
		}
	}
\end{lstlisting}
Die Update-Funktion von Unity wird jeden Frame aufgerufen und überprüft ob die Booleans für die linke und rechte Seite \textit{true} sind oder ob eine Seite noch nicht ausgewählt wurde. Wenn auf beiden Seiten etwas ausgewählt wurde, kann das Spiel gestartet werden. Wenn eine der beiden Variablen \textit{false} ist, ist der Start-Button deaktiviert. Um einen Button zu aktivieren oder zu deaktivieren wird die Variable \textit{interactable} des Buttons auf \textit{false} oder \textit{true} gesetzt. Je nachdem ist der Button im Spiel dann ausgegraut oder eben nicht.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs GoBack-Funktion}]
	public void GoBack(){
		MenuPickLevel.loadButtonsPrefab = 0;
		SceneManager.LoadScene("MenuLearning");
	}
\end{lstlisting}
Die GoBack-Funktion wird aufgerufen, wenn der Zurück-Button gedrückt wurde. In dieser wird die static Variable aus dem vorherigen Skript wieder auf null gesetzt, damit es zu keinem Fehler in der Levelauswahl kommt, da diese sonst den vorherigen Wert weiterhin besitzen würde. Danach wird mithilfe des Aufrufes \textit{SceneManager.LoadScene("MenuLearning")} die Menüauswahl-Szene aufgerufen.
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs LoadGame-Funktion}]
	public void LoadGame(){
		switch (loadButtonsNumber)
		{
			case 2:
				SceneManager.LoadScene("CompareQuantities");
				break;
			case 3:
				SceneManager.LoadScene("basicOperations");
				break;
			case 4:
				SceneManager.LoadScene("triangle");
				break;
			case 5:
				SceneManager.LoadScene("lightningView");
				break;
			case 6:
				SceneManager.LoadScene("finishPattern");
				break;
			case 7:
				SceneManager.LoadScene("MixedWords");
				break;
			default:
				break;
		}
	}
\end{lstlisting}
Die Funktion \textit{LoadGame} kontrolliert mithilfe eines \textit{switch-case}-statements, welcher Button in der Szene davor gedrückt wurde, um anschließend die passende Szene zu laden\\
Das Problem, was nach der Verbesserung des ersten Skripts aufgetreten ist, war dass die Szene mit den Grundrechenarten die Zahl vier zugewiesen bekommen sollte, diese war aber der dritte Fall im switch-case-statement und somit wurde in dieser Szene immer die Rechenmauer geladen. Die Zahlen wurden dann im Skript davor angepasst und die Grundrechenarten bekamen die nummer drei zugewiesen. Dies führte in der Funktion \textit{SpawnButtonsLeft} zu Problemen.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs-SafeOptionsRight Funktion}]
	public void SafeOptionsRight(int whichButton){
		for (int i = 0; i < rightSideList.Count; i++){
			if(i != whichButton){
				rightSideList[i].interactable = true;
				continue;
			}
			rightSide = true;
			rightSideList[i].interactable = false;
		}
		switch (whichButton)
		{
			case 0:
				lvlAmmountStatic = 10;
				maxNumberStatic = 10;
				wallSize = 3;
				break;
			case 1:
				lvlAmmountStatic = 15;
				maxNumberStatic = 15;
				wallSize = 4;
				break;
			case 2:
				lvlAmmountStatic = 20;
				maxNumberStatic = 20;
				wallSize = 5;
				break;
			default:
				break;
		}
	}
\end{lstlisting}
In dieser Funktion wird die Auswahl der Schwierigkeit des Levels gespeichert. Diese bekommt eine Zahl zwischen null und zwei zugewiesen. In einer \textit{For}-Schleife wird dann überprüft welcher Button, gedrückt wurde. Wenn ein Button der ungleich i gedrückt wurde, wird dieser aktiviert und die Schleife springt einen Durchgang weiter. Wenn i die gleiche Zahl wie die Variable \textit{whichButton} ist, wird der Boolean auf \textit{true} gesetzt und der aktuell gedrückte Button wird deaktiviert.\\
Nachdem die Schleife durchgelaufen ist, wird mithilfe eines \textit{switch-case}-statements überprüfut welcher der drei Buttons ausgewählt wurde und je nachdem eine Levelanzahl, eine maximale random Nummer und die Mauergröße gespeichert.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs SafeOptionsLeft-Funktion}]
	public void SafeOptionsLeft(int whichButton){
		for (int i = 0; i < leftSideList.Count; i++){
			if(i != whichButton){
				leftSideList[i].interactable = true;
				continue;
			}
			leftSide = true;
			leftSideList[i].interactable = false;
		}
		if(loadButtonsNumber == 2){
			setQuantitiesOptions(whichButton);
		}
		else if(loadButtonsNumber == 3){
			setMathOptions(whichButton);
		}

	}
\end{lstlisting}
Die Funktion SafeOptionsLeft Speichert welche der Alternativen links gespeichert wurde. Also wird einmal wie in der Funktion \textit{SafeOptionsRight} mithilfe einer \{For}-Schleife kontrolliert welcher Button gedrückt wurde und dieser wird dann deaktiviert. Die Boolean Variable für links wird dann auch auf \textit{true} gesetzt. Da es in zwei Leveln Alternativen gibt, wird überprüft welches Level gewählt wurde. Im Fall der Zahl Zwei wird die Funktion aufgerufen, die Speichern soll ob die Kinder Objekte oder Zahlen vergleichen sollen. Im Fall der Drei wird die Funktion aufgerufen, die speichert welche der vier Grundrechenarten das Kind spielen möchte. 
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs setQuantitiesOptions-Funktion}]
	public void setQuantitiesOptions(int whichButton){
		switch (whichButton)
		{
			case 0:
				fourChoices = 1;
				break;
			case 1:
				fourChoices = 2;
				break;
			default:
				break;
		}
	}
\end{lstlisting}
Diese Funktion überprüft mithilfe eines \textit{switch-case}-statements welche der beiden Varianten ausgewählt wurde und speichert diese in die Variable \textit{fourChoices}. Durch diese weiß das Spiel "größer, kleiner, gleich"\ ob es Zahlen oder Objekte anzeigen soll.
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs setMathOptions-Funktion}]
	public void setMathOptions(int whichButton){
		switch (whichButton)
		{
			case 0:
				fourChoices = 1;
				break;
			case 1:
				fourChoices = 2;
				break;
			case 2:
				fourChoices = 3;
				break;
			case 3:
				fourChoices = 4;
				break;
			default:
				break;
		}
	}
\end{lstlisting}
Dieses Skript arbeitet gleich wie das Skript davor. Es überprüft welche der vier Grundrechenarten ausgewählt werden sollte und speichert diese ab, damit das Skript der Grundrechenarten weiß ob das Kind addieren, subtrahieren, multiplizieren oder dividieren möchte.
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs SpawnButtonsLeft-Funktion}]
	public void SpawnButtonsLeft(){
		int size = 0;
		if(loadButtonsNumber == 3) size = 4;
		else size = 2;
		for (int i = 0; i < size; i++){
			int copy = i;
			spawnedObject = Instantiate(buttonPref, spawnerLeft.transform.position, Quaternion.identity);
			spawnedObject.name += i;
			spawnedObject.transform.SetParent(spawnerLeft.transform);
			spawnedObject.transform.localScale = scaleSize;
			spawnedObject.GetComponent<Image>().preserveAspect = true;
			leftSideList.Add(spawnedObject.GetComponent<Button>());
			leftSideList[i].onClick.AddListener(() => SafeOptionsLeft(copy));
			if(size == 2){
				leftSideList[i].GetComponentInChildren<Image>().sprite = quantitiesModes[i];
				// leftSideList[i].GetComponentInChildren<Image>().preserveAspect = true;
				continue;
			}
			else if(size == 4){
				leftSideList[i].GetComponentInChildren<Image>().sprite = mathModes[i];
			}
		}
	}
\end{lstlisting}
In diesem Skript kam es zu einem Problem, nachdem das erste Menü Skript angepasst wurde. Dieses Skript läuft mit einer \textit{For}-Schleife durch und erzeugt je nachdem welche Zahl in der Variablen \textit{loadButtonsNumber} steht die richtige Anzahl an Buttons. Für das Spiel "größer, kleiner, gleich"\ erzeugt es zwei Buttons und für die Grundrechenarten vier. Da aber die Grundrechenarten die Nummer Drei bekamen wurde ein Button zu wenig erzeugt. Um dies zu verhindern, wird am Anfang einmal überprüft ob die \textit{loadButtonsNumber} zu diesem Zeitpunkt eine drei beinhaltet und wenn ja wird die Größe auf vier gesetzt, wenn das nicht der Fall ist wird diese auf zwei gesetzt. Somit wird die richtige Anzahl an Buttons für die Alternativen erzeugt.\\
Die \textit{For}-Schleife muss auch hier wieder eine temporäre Variable erzeugen, hier wurde sie \textit{copy} genannt. Um Objekte durch ein Skript zu erzeugen, wird in das Objekt \textit{spawnedObject} mithilfe der Instantiate-Methode, dies ist eine Methode um ein Objekt zu spawnen der Button erzeugt. Die Instantiate-Methode bekommt ein \textit{GameObject} das sie spawnen soll, in diesem Fall den Button Prefab. Dann benötigt sie eine Position, das wäre die Position des Spawners auf der linken Seite. Diese bekommt man durch den Aufruf \textit{spawnerLeft.transform.position}. Dieser gibt die Position des \textit{GameObject} auf der linken Seite zurück und an dieser Stelle soll der Button erzeugt werden. Da sie keine Rotation benötigt, wird als letzer Übergabewert \textit{Quaternion.identity} verwendet.
Damit in Unity die Objekte in der Hierarchie unterscheidbar waren, bekamen sie an den Namen ein "i"\ angehängt(spawnedObject0).\\
Um die Buttons richtig anzuordnen wurde ein Overlay mit vertikalen und horizontalen Layoutgroups angelegt. In der Abbildung 5.23 ist dies zu sehen. Das Objekt \textit{Choices}  eine bekam eine horizontale Layoutgruppe, die Objekte \textit{leftSite} und \textit{rightSite} bekamen eine vertikale Layoutgruppe. 
%TODO Maybe noch ein Bild
Damit die Buttons in diesen Objekten zu sehen sind, wird dem \textit{spawnedObjekt} ein Elternobjekt zugewiesen. Um dies zu erreichen, wird \textit{spawnedObject.transform.SetParent} aufgerufen. Danach wird das Objekt an der richtigen Stelle angezeigt, aber nicht in der richtigen Größe. Unity skaliert das Objekt kleiner, da es hierbei die Größe des Objekts nimmt in dem das neue Objekt erzeugt wird. Damit das Objekt die Originalgröße behält, wird für das erzeugte Objekt die Skalierung auf die originale Größe gesetzt. Auch dies ist mithilfe des \textit{.transfom.localScale} Befehls möglich.\\
Bilder in Unity werden unscharf dargestellt. Dies kann verhindert werden, wenn die Option \textit{preserveAspect} auf \textit{true} gesetzt wird. Dies wird auch für jedes erzeugte Objekt in dieser Funktion erledigt.\\
Nachdem alle Buttons für die linke Seite erzeugt wurden, werden diese in die Liste \textit{LeftSideList} gespeichert und bekommen danach den Listener zugewiesen. Dieser ruft dann die Funktion auf, die speichert welche Alterantive des Spiels gespeichert werden soll.\\
Nachdem die Buttons links erzeugt wurden, muss die Funktion in einer \textit{If} und \textit{else if}-Abfrage überprüfen welche Bilder den Buttons zugewiesen werden sollen, sonst würde auf den Buttons nichts stehen. Wenn die Variable \textit{size} die Zahl Zwei beinhaltet, wird auf den Button Links in den Komponenten Image das passende Bild aus dem Array gespeichert. Der Befehl \textit{leftSideList[i].GetComponentInChildren<Image>().sprite = quantitiesModes[i];} nimmt die Komponeten des Buttons aus der Liste \textit{leftSideListe} und fügt das Bild aus dem Array an der Stelle i ein.\\
Für die Grunrechenarten wird dasselbe angewandt, in dem fall ist die Variable gleich vier ist.
\graphic{LayoutMenuAdvanced}{Layout Erweitertes-Menü}
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs SpawnButtonsRight-Funktion}]
	public void SpawnButtonsRight(){
		for (int i = 0; i < 3; i++){
			int copy = i;
			spawnedObject = Instantiate(buttonPref, spawnerRight.transform.position, Quaternion.identity);
			spawnedObject.name += i;
			spawnedObject.transform.SetParent(spawnerRight.transform);
			spawnedObject.transform.localScale = scaleSize;
			spawnedObject.GetComponent<Image>().preserveAspect = true;
			rightSideList.Add(spawnedObject.GetComponent<Button>());
			rightSideList[i].onClick.AddListener(() => SafeOptionsRight(copy));
			rightSideList[i].GetComponentInChildren<Image>().sprite = difficulty[i];
			// rightSideList[i].GetComponentInChildren<Image>().preserveAspect = true;
		}
	}
\end{lstlisting}
Die Funktion \textit{SpawnButtonsRight} arbeitet gleich wie die SpawnButtonsLeft-Funktion, nur dass in diesem Fall immer drei Buttons gespawnt, auf die richtige größe skaliert und in eine Liste eingefügt werden. Diesen werden danach dann die Bilder der unterschiedlichen Schwierkeitsgrade hinzugefügt.
\subsection{Szene - Grundrechenarten}
\subsubsection{Grundrechenarten - Design}
\graphic{addition}{Grundrechenarten - Addition}
In der Szene der Grundrechenarten gibt es ein Textfeld, welches mit einem grünen Pfeil markiert wurde. In diesem steht der Operator, also ob das Kind addieren, subtrahieren, multiplizieren oder dividieren soll. Die Szene kann mit dem Menü-Button oben links verlassen werden. Die Überschrift der Szene sagt dem Kind, dass es den Term ausrechnen soll. Ganz rechts oben steht das aktuelle Level und wie viele es insgesamt gibt. Dies wird, sobald das Kind eine Rechnung richtig hat, um eins hochgezählt. In der Mitte der Szene steht links die erste Zahl, dann der Operator, dann die zweite Zahl. Danach kommt das Gleichheitszeichen und ein Eingabefeld für die Lösung des Nutzers. Dieses Feld wird grün umrandet, wenn die Lösung richtig ist und rot, wenn diese falsch ist. Nach einer falschen Eingabe wird das Eingabefeld wieder geleert. In der Abbildung 5.24 und 5.25 ist der grüne und rote Rand zu sehen. Dieser wird in diesem Fall aus der Szene "größer, kleiner, gleich"\ sein, ist aber in den Szenen, in denen er verwendet wird, gleich. 
\graphic{rightChoiceQuantities}{Grüner Rahmen}
\graphic{wrongChoiceQuantites}{Roter Rahmen}
Der Button \textit{Testen} löst die Funktion aus, die kontrolliert, ob richtig gerechnet wurde. Dieser ist deaktiviert, solange keine Zahl eingeben wurde und wird aktiviert, sobald eine Zahl darin steht.
\subsubsection{Grundrechenarten - Skript}
\begin{lstlisting}[language=csh, caption={MathOperations.cs Variablen-Deklaration}]
public class MathOperations : MonoBehaviour
{

	public Text TextNumberLeft;
	public Text TextNumberRight;
	public Text operatorSymbole;
	public Text showLevelNumber;

	public InputField solutionNumber;

	public Button checkButton;
	public Button menu;

	public Image imageColor;

	private int leftNumber;
	private int rightNumber;
	private int solution;
	private int maxRandomNumber = 10;
	private int minRandomNumber = 0;
	private int lvlNumber = 10;
	private int countLvl = 0;
	//add = 1, sub = 2, mult = 3, div = 4
	private int gameMode = 3;
	private int wrongSolution = 0;
\end{lstlisting}
In dem Skript für die Szene werden zuerst vier public Textfelder deklariert. Diese zeigen verschiedene Informationen an. Eines zeigt das aktuelle Level und wie viele es insgesamt gibt. Dann zeigt eines der Textfelder den Operator an, mit dem das Kind rechnen soll. Die letzten zwei Textfelder zeigen die Zahlen an, die addiert, subtrahiert, multipliziert oder dividiert werden sollen. In dieser Szene benötigt der Schüler/die Schülerin ein Eingabefeld, in das seine/ihre Lösung geschrieben werden kann. Das Skript bekommt auch zwei Buttons zugewiesen, einen der in das erste Menü zurückführt und einen, der das Ergebnis überprüft. Um den Kontrollrahmen zu erzeugen, wird ein Objekt vom Typ Image benötigt, dieses liegt hinter dem Eingabefeld und ist ein wenig größer als das Input-Feld selbst. Als Letztes benötigt das Skript noch ein paar Variablen um die Zahlen links und rechts zu speichern. Das Skript benötigt eine Variable, die das Ergebnis der Rechnung speichert. Des Weiteren sind zwei Variablen deklariert, um die zufällig generierten Zahlen zu begrenzen. Es gibt eine Variabel, die die maximale Anzahl an Leveln festlegt und einen Zähler, der nach oben gezählt wird. Es gibt noch zwei letzte Variablen im Skript. Die eine legt den Modus fest, also ob addiert, subtrahiert, multipliziert oder dividiert wird und die andere zählt die Anzahl der Fehler, die das Kind macht.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs Start-Funktion}]
	void Start()
	{
		menu.onClick.AddListener(() => GoBack());
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		gameMode = MenuPickLevelAdvanced.fourChoices;
		checkButton.onClick.AddListener(() => buttonClick());
		checkButton.interactable = false;
		solutionNumber.onValueChanged.AddListener(delegate {EnableButton(); });
		PlayGame(gameMode);
	}
\end{lstlisting}
In der Start-Funktion der Szene werden am Anfang ein Listener für den Menü-Button und einen für den Test-Button zugewiesen. In dieser Methode, werden die statischen Variablen, die in der Szene davor gesetzt wurden aufgerufen und in die passenden Variablen gespeichert.
So weiß das Skript nun, ob es \textit{Addieren, Subtrahieren, Multiplizieren oder Dividieren} laden soll. Der Button zum Testen wird am Anfang deaktiviert, da wenn das Eingabefeld leer ist und der Button gedrückt wird die Szene einfriert. Damit dies verhindert wird, wird der Button beim Start der Szene deaktiviert. Wenn das Kind eine Zahl in das Eingabefeld eingibt, wird der Button aktiviert. Dies ist mit der onValueChange Methode für das Eingabefeld möglich. Diese bekommt einen Listener, der die Funktion \textit{EnableButton} aufruft und dann den Button aktiviert oder deaktiviert. Als Letztes ruft die Start-Funktion die Funktion \textit{PlayGame} auf. Diese wird mit dem Übergabeparameter des Gamemodes aufgerufen.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs EnableButton-Funktion}]
	public void EnableButton(){
		if(string.IsNullOrEmpty(solutionNumber.text)){
			checkButton.interactable = false;
			solutionNumber.interactable = true;
		}
		else{
			checkButton.interactable = true;
		}
	}
\end{lstlisting}
Die EnableButton-Funktion überprüft bei jeder Änderung des Wertes, ob das Input Feld leer ist oder nicht. Dies erfolgt mit der IsNullOrEmpty-Abfrage, da aber eine Integerzahl eingegeben wird, muss diese mit \textit{string.} in einen String umgewandelt werden. Wenn das Feld leer ist, wird der Button deaktiviert und das Eingabefeld aktiviert, sodass der Schüler/die Schülerin eine Eingabe tätigen kann. Wenn das Feld gefüllt ist, wird der Testbutton aktiviert. Damit in den jeweiligen Szenen keine falsche Eingabe gemacht werden kann, also bei den mathematischen Spielen kein Text und bei dem Deutsch-Spiel keine Zahl eingegeben werden kann, wird in Unity die Eingabe auf den jeweiligen Wert festgelegt. Dies ist in Abbildung 5.27 zu sehen.
\graphic{inputType}{Festlegen welcher Wert in das Input-Feld geschrieben werden darf}
Die Erklärung des Codes der Funktion, die in das Menü zurückkehrt, wird nicht eingefügt, da etwas in dieser Art schon erklärt wurde. Dieser setzt die statischen Variablen auf den Ursprungswert zurück und lädt die Menüszene.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs PlayGame-Funktion}]
public void PlayGame(int gameMode){
		countLvl++;
		if(countLvl > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", wrongSolution);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + wrongSolution);
		}
		//change color to white
		imageColor.color = new Color32(255, 255, 255, 255);

		if(countLvl <= lvlNumber)	showLevelNumber.text = "Level: " + countLvl + "/" + lvlNumber;
		solutionNumber.text = "";
		if(gameMode == 4){
			operatorSymbole.text = "/";
			minRandomNumber = 1;
			leftNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			rightNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			solution = leftNumber * rightNumber;
			SetNumbersLeftAndRight(solution, rightNumber);
			return;
		}
		else if(gameMode == 2){
			minRandomNumber = 0;
			leftNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			rightNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			if(leftNumber < rightNumber){
				Debug.Log(" leftNumber: " + leftNumber + " rightNumber: " + rightNumber + "zweite If");
				SetNumbersLeftAndRight(rightNumber, leftNumber);
				solution = rightNumber - leftNumber;
			}
			else{
				Debug.Log(" leftNumber: " + leftNumber + " rightNumber: " + rightNumber + "zweite If");
				SetNumbersLeftAndRight(leftNumber, rightNumber);
				solution = leftNumber - rightNumber;
			}
			operatorSymbole.text = "-";
			return;
		}
		else{
			minRandomNumber = 0;
			leftNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			rightNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			SetNumbersLeftAndRight(leftNumber, rightNumber);
			if(gameMode == 1){
				operatorSymbole.text = "+";
				solution = leftNumber + rightNumber;
			}
			else{
				operatorSymbole.text = "*";
				solution = leftNumber * rightNumber;
			}
			return;
		}
	}
\end{lstlisting}
Die PlayGame-Funktion, zählt den Zähler für die Anzahl der Level bei jedem Aufruf um eins nach oben. Das Skript testet dann, ob der Counter über der Anzahl zu spielenden Level ist und wenn dies der Fall ist, wird in einer Datei die Anzahl an Fehlern gespeichert und die Szene, die den \textit{finishScreen} lädt, geladen. In diesem Fall wird die Anzahl an Fehlern nicht in einer statischen Variable gespeichert, da diese im Skript der End Szene deklariert werden müsste. Die statische Variable muss dann nach jedem aufruf der Szene \textit{finishScreen} wieder auf null gesetzt werden. Durch das speichern in einer Datei, wird diese einfach mit dem neuen wert überspeichert.\\
Das Skript muss den Rahmen des Eingabefeldes beim Aufruf der PlayGame-Funktion wieder auf die Farbe weiß setzen. Das Skript setzt die Anzahl an Leveln in das passende Textfeld, solange der Zähler nicht größer als die maximale Anzahl an Leveln ist. Bei jedem Aufruf der Funktion wird das Eingabefeld geleert, sodass keine Zahl in dem Feld steht.\\
Für jede Art der Grundrechenarten werden andere Vorbereitungen benötigt, um eine korrekte Rechnung zu erstellen. Wenn das Kind dividieren soll, muss das Operator-Textfeld das Symbol "/"\ anzeigen. Damit eine Division entsteht, die mathematisch korrekt ist, wird die kleinste Zahl, die zufällig generiert werden kann, auf eins gesetzt. Danach werden zwei Zahlen für das linke und rechte Textfeld generiert und die Lösungsvariable \textit{solution} wird druch eine Multiplikation berechnet. Der Grund dafür ist, dass wenn eine Zahl durch eine Multiplikation erzeugt wird und diese durch eine der beiden zufälligen Zahlen dividiert wird, auf jeden Fall keine Dezimalzahl als Ergebnis herauskommt. Daher wird das Ergebnis der Rechnung in das linke Feld und die rechten Zahlen in das rechte Feld geschrieben. Das Ergebnis ist in diesem Fall dann immer die Zahl, die für die linke Seite erzeugt wurde.\\
Im Falle einer Subtraktion werden wieder zufällige Zahlen erzeugt, dieses Mal ist die kleinstmögliche Zahl allerdings eine Null. Damit das Ergebnis keine negative Zahl werden kann,, wird überprüft welche Zahl die größere ist. Diese wird in die linke Seite geschrieben und die kleinere in die rechte Seite. Das Ergebnis wird dann entweder \textit{linke Zahl - rechte Zahl} oder \textit{rechte Zahl - linke Zahl} berechnet.\\
Für den Fall der Addition und Multiplikation, können beide Zahlen unbesorgt für die linke und rechte Seite erzeugt werden. Hierbei sollte überprüft werden, ob im Feld für den Operator ein Plus oder ein Asterisk(Stern) zu sehen ist und wie die Lösung berechnet werden muss.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs RandomNumber-Funktion}]
	public int RandomNumbers(int minRandomNumber, int maxRandomNumber){
		return UnityEngine.Random.Range(minRandomNumber, maxRandomNumber);
	}
\end{lstlisting}
In dieser Funktion wird eine zufällige Zahl mithilfe der von Unity bereitgestellten Funktion generiert. Die Funktion erzeugt eine zufällige Zahl in der Reichweite einer kleinstmöglichen und einer maximalen Zahl.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs SetTextLeftAndRight-Funktion}]
	public void SetNumbersLeftAndRight(int left, int right){
			TextNumberLeft.text = left.ToString();
			TextNumberRight.text = right.ToString();
	}
\end{lstlisting}
Diese Funktion setzt die zwei übergebenen Zahlen in die linke und rechte Seite der Textfelder. Indem von dem Objekt \textit{Textfield} die Komponente \textit{.text} aufgerufen wird, kann in diese die Integerzahl, nachdem sie in einen String umgewandelt wurde, einspeichert werden.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs ButtonClick-Funktion}]
	public void buttonClick(){
		checkButton.interactable = false;
		if(gameMode == 4){
			StartCoroutine(waiterDiv(1));
		}
		else{
			StartCoroutine(waiter(1));
		}
	}
\end{lstlisting}
Wenn der Test-Button gedrückt wurde, wird je nach Game Mode eine \textit{Coroutine} aufgerufen. Diese wird verwendet, um zwischen den Leveln eine Sekunde zu warten und dem Kind zu zeigen, dass das Ergebnis richtig oder falsch ist. Da die Division anders überprüft werden muss, als die anderen drei Rechenarten, bekam diese eine eigene \textit{Coroutine}.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs waiter-Coroutine}]
	IEnumerator waiter(int sec){
		solutionNumber.interactable = false;
		if(countLvl <= lvlNumber){
			if(int.Parse(solutionNumber.text) == solution){
				//change color green
				imageColor.color = new Color32(37, 250, 53, 255);
				yield return new WaitForSeconds(sec);
				PlayGame(gameMode);
			}
			else{
				wrongSolution++;
				//change color red
				imageColor.color = new Color32(251, 37, 37, 255);
				yield return new WaitForSeconds(sec);
				//change color to white
				imageColor.color = new Color32(255, 255, 255, 255);
				solutionNumber.text = "";
			}
		}
	}
\end{lstlisting}
Dies ist die \textit{Coroutine} für alle Grundrechenarten außer der Division. Die beiden Funktionen sind sich aber sehr ähnlich, daher wird nur eine erklärt. Als Erstes wird das Eingabefeld deaktiviert, da schnell schreibende Kinder während die Lösung angezeigt, dass das Ergebnis falsch ist. Schon die richtige Zahl eingeben können ohne zu warten bis dieser Ablauf einmal durchgelaufen ist. Danach wird überprüft, ob das Kind überhaupt noch Level zu spielen hat. Wenn dies der Fall ist, wird das Ergebnis mit der Eingabe verglichen. Wenn diese gleich ist, wird der Rahmen des Eingabefeldes für eine Sekunde grün, danach wird das nächste Level geladen. Wenn das Kind falsch gerechnet hat, wird der Zähler für die Fehler hochgezählt und die Farbe des Rahmens wird für eine Sekunde rot, danach wird dieser wieder weiß gefärbt. Die Farbe eines Objektes kann geändert werden, indem von dem Objekt die Komponente \textit{.color} aufgerufen wird und es eine neue Farbe zugewiesen bekommt, wie zum Beispiel \textit{new Color32(255, 255, 255, 255);} für die weiße Farbe. Das Eingabefeld wird geleert, aber keine neue Rechnung geladen.\\
Der Unterschied zur Überprüfung der Division ist, in der Abfrage, anstatt zu testen ob die Eingabe das gleiche ist wie die Lösung, wird getestet, ob die Eingabe das gleiche wie die Zahl, die für das linke Feld generiert wurde ist.
\subsection{Szene - Mengen vergleichen}
\subsubsection{Mengen vergleichen - Design}
\graphic{quantitiesObjects}{größer, kleiner, gleich}
In dieser Szene gibt es zwei Möglichkeiten das Spiel zu spielen. Entweder werden in dem großen Feldern links und rechts mittig Zahlen oder mithilfe einer \textit{Layout Group} Objekte in vier Reihen eingefügt. Der Header der Szene beinhaltet einen Menü-Bbutton, eine kleine Aufgabenstellung und die Level-Anzeige. In der Mitte der Szene befindet sich ein leeres Viereck, welches anzeigt,welcher der unteren Buttons gedrückt wurde und ob die Lösung richtig oder falsch ist. Dies ist wieder mit einem grünen oder roten Rahmen umgesetzt. Ganz unten in der Szene gibt es drei verschiedene Buttons für die jeweilige Option "größer"\, "kleiner"\ oder "gleich"\. Die Buttons werden nach dem Auswählen einer Option deaktiviert, bis das nächste Level geladen hat oder bis das Kind erneut versuchen kann, die richtig Lösung zu bestimmten. Die Buttons mussten deaktiviert werden, da bei der richtigen Lösung auf den zutreffenden Button zehnmal gedrückt werden könnte und somit das Spiel nach einer Runde beendet wäre.\\
\subsubsection{Mengen vergleichen - Skript}
\begin{lstlisting}[language=csh, caption={GameQuantities.cs Variablen-Deklaration}]
public class GameQuantities : MonoBehaviour {
	//the Textfields I fill
	public Text TextfieldLeft;
	public Text TextfieldRight;
	public Text TextfieldLevel;
	public Text Symbol;

	//collider for Objects
	public Collider2D spawnerLeftCollider;
	public Collider2D spawnerRightCollider;

	//my Gameobjects to compare Quantities
	public GameObject objectLeft;
	public GameObject objectRight;
	public GameObject spawnerLeft;
	public GameObject spawnerRight;
	private GameObject spawnedObject;

	//array with gameObjects
	private List<GameObject> alleQuantitiesObjects = new List<GameObject>(40);

	public Image imageColor;

	//Buttons
	public Button lessBtn;
	public Button equalsBtn;
	public Button greaterBtn;
	public Button menu;

	//variables for compare Quantities
	private int numberLeft = 0;
	private int numberRight = 0;
	private int randomNumber = 0;
	private int counterRound = 0;
	private int counterWrongChoice = 0;
	private Vector3 scaleSize = new Vector3 (1.0f, 1.0f, 1.0f);

	//number of lvls
	private int lvlNumber = 10;
	private int maxNumber = 0;

	//1 für mit objekten, 2 für mit zahlen
	private int lvlChoice = 1;
\end{lstlisting}
In dieser Szenen werden viele Variablen benötigt, diese einzeln zu erklären dauert zu lange. Die Szene benötigt, zwei Textfelder für die Zahlen links und rechts, in diesen Vierecken existieren auch zwei leere Felder, die als Spawner für die Objekte dienen. Ein Textfeld dient dem Zeichen des Vergleiches, also "größer"\, "kleiner"\, "gleich"\. In diese wird eine dafür vorhergesehene Variable geschrieben. Das Skript benötigt vier Buttons und eine Liste für die erzeugten Objekte. Um die Zahlen, Objekte und den Spielmodus zu vergleichen, werden Variablen deklariert, die in den einzelnen Funktionen verwendet werden. Da auch in dieser Szene die erzeugten Objekte wieder zu klein erzeugt werden, wird ein weiterer Vektor benötigt, der diese auf die Originalgröße zurückskaliert.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs Start-Funktion}]
	void Start() {
		menu.onClick.AddListener(() => GoBack());
		maxNumber = MenuPickLevelAdvanced.maxNumberStatic;
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		lvlChoice = MenuPickLevelAdvanced.fourChoices;
		lessBtn.onClick.AddListener(() => SetSymbol('<'));
		equalsBtn.onClick.AddListener(() => SetSymbol('='));
		Debug.Log("Lvl Ammount: " + lvlNumber);
		greaterBtn.onClick.AddListener(() => SetSymbol('>'));
		PlayGame();
	}
\end{lstlisting}
Die Start Funktion erzeugt wieder für den jeweiligen Button einen Listener. Für die Buttons, mit der Auswahl der drei Zeichen, wird eine Funktion aufgerufen, die das aktuelle Symbol in das Textfeld in der Mitte setzt. Die statischen Variablen aus dem Menü davor werden wieder für die Anzahl an Leveln verwendet und um zu kontrollieren, ob Zahlen oder Objekte erzeugt werden.\\

Die Funktion für das zurückkehren in das Menü wurde in den vorherigen Kapiteln schon erklärt.\\

\begin{lstlisting}[language=csh, caption={GameQuantities.cs SetSymbol-Funktion}]
	public void SetSymbol(char symbol){
		lessBtn.interactable = false;
		equalsBtn.interactable = false;
		greaterBtn.interactable = false;
		Symbol.text = symbol.ToString();
		StartCoroutine(waiter(1, symbol));
	}
\end{lstlisting}
Die Funktion bekommt das Zeichen "<"\, "="\ oder ">"\ übergeben. Sobald einer der drei Buttons gedrückt wurde, werden alle drei Buttons deaktiviert, das Textfeld gesetzt und die \textit{Coroutine} zur Überprüfung des Ergebnisses aufgerufen.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs PlayGame-Funktion}]
	public void PlayGame() {
		counterRound++;
		if(counterRound > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", counterWrongChoice);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + counterWrongChoice);
		}
		Debug.Log("Round: " + counterRound);
		lessBtn.interactable = true;
		equalsBtn.interactable = true;
		greaterBtn.interactable = true;
		//change color to white
		imageColor.color = new Color32(255, 255, 255, 255);
		if(counterRound <= lvlNumber)	SetLevelText();
		Symbol.text = "";
		if (lvlChoice == 2) {
			numberLeft = GenerateNumber(maxNumber);
			numberRight = GenerateNumber(maxNumber);
			SetTextLeftAndRight(numberLeft, numberRight);
		} else if (lvlChoice == 1) {
			numberLeft = GenerateNumber(16);
			numberRight = GenerateNumber(16);
			SpawnQuantitiesObjects(numberLeft, spawnerLeft, objectLeft);
			SpawnQuantitiesObjects(numberRight, spawnerRight, objectRight);
		}
	}
\end{lstlisting}
Die PlayGame-Funktion zählt wieder für jeden Aufruf den Level-Zähler nach oben und überprüft, ob genug Level gespielt wurden. Wenn das nicht der Fall ist, wird die aktuelle Level-Zahl angezeigt und die Buttons werden wieder aktiviert. Die Funktion ändert die Rahmenfarbe auf weiß und leert das Feld mit dem Symbol wieder. Je nachdem welcher Modus gewählt wurde, werden die zwei zufällig generierten Zahlen als Zahl in die Felder geschrieben oder es werden maximal 16 Objekte für jede Seite erzeugt und angezeigt.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs SpawnQuantitiesObjects-Funktion}]
	public void SpawnQuantitiesObjects(int number, GameObject spawner, GameObject side) {
		for (int i = 0; i < number; i++) {
			spawnedObject = Instantiate(side, spawner.transform.position, Quaternion.identity);
			spawnedObject.name += i;
			spawnedObject.transform.SetParent(spawner.transform.GetChild(i / 4));
			spawnedObject.transform.localScale = scaleSize;
			alleQuantitiesObjects.Add(spawnedObject);
		}
	}
\end{lstlisting}
Die Funktion bekommt als Übergabe eine Zahl, einen der beiden Bereiche, in denen die Objekte erzeugt werden sollen und das Objekt, das erzeugt werden soll, da dieses für links ein anderes als für rechts ist. Das Skript läuft eine \textit{for}-Schleife durch, die die gewünschte Zahl an Objekten erzeugen soll. Da in dieser Szene in jeder der Reihen nur vier Objekte passen, wird in der \textit{Layout-Group} an der Stelle $\frac{i}{4}$ das Objekt gesetzt, so wird nach vier Objekten die nächste Reihe verwendet. Am Schluss der Funktion werden die Objekte in eine Liste gespeichert.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs Delete-Funktion}]
	public void DeleteObjects() {
		foreach (GameObject child in alleQuantitiesObjects) {
			Destroy(child);
		}
	}
\end{lstlisting}
Die Objekte, die in die Liste gespeichert werden, nach dem Lösen eines Levels wieder gelöscht. Die Funktion iteriert mit einer \textit{foreach}-Schleife durch alle Objekte der Liste und löscht diese aus der Szene. Somit werden nicht immer nur mehr Objekte erzeugt.\\

Die nächsten drei Funktionen des Skriptes würden nur wieder zeigen, wie die Zufallszahlen erzeugt werden und wie die Textfelder der Levelanzahl und die Zahlen angezeigt werden sollen.\\

\begin{lstlisting}[language=csh, caption={GameQuantities.cs waiter-Coroutine}]
IEnumerator waiter(int sec, char symbol){
		if(counterRound <= lvlNumber ){
			if(symbol.Equals('<')){
				Symbol.text = '<'.ToString();
				if (numberLeft < numberRight) {
					Debug.Log("Richtig");
					//change color green
					imageColor.color = new Color32(37, 250, 53, 255);
					yield return new WaitForSeconds(sec);
					DeleteObjects();
					PlayGame();
				} else {
					counterWrongChoice++;
					//change color red
					imageColor.color = new Color32(251, 37, 37, 255);
					yield return new WaitForSeconds(sec);
					EnableButtons();
					imageColor.color = new Color32(255, 255, 255, 255);
					Symbol.text = "";
					Debug.Log("Nicht richtig");
				}
			}
			if(symbol.Equals('=')){
				Symbol.text = '='.ToString();
				if (numberLeft == numberRight) {
					Debug.Log("Richtig");
					//change color green
					imageColor.color = new Color32(37, 250, 53, 255);
					yield return new WaitForSeconds(sec);
					DeleteObjects();
					PlayGame();
				} else {
					counterWrongChoice++;
					//change color red
					imageColor.color = new Color32(251, 37, 37, 255);
					yield return new WaitForSeconds(sec);
					EnableButtons();
					imageColor.color = new Color32(255, 255, 255, 255);
					Symbol.text = "";
					Debug.Log("Nicht richtig");
				}
			}
			if(symbol.Equals('>')){
				Symbol.text = '>'.ToString();
				if (numberLeft > numberRight) {
					Debug.Log("Richtig");
					//change color green
					imageColor.color = new Color32(37, 250, 53, 255);
					yield return new WaitForSeconds(sec);
					DeleteObjects();
					PlayGame();
				} else {
					counterWrongChoice++;
					//change color red
					imageColor.color = new Color32(251, 37, 37, 255);
					yield return new WaitForSeconds(sec);
					EnableButtons();
					imageColor.color = new Color32(255, 255, 255, 255);
					Symbol.text = "";
					Debug.Log("Nicht richtig");
				}
			}
		}
	}
\end{lstlisting}
Die \textit{Coroutine} ist dafür zuständig zu überprüfen, ob die Zahl im linken Feld kleiner, gleich oder größer der Zahl im rechten Feld ist. Die Funktion überprüft zuerst, welches Symbol ausgewählt wurde, indem es das eingespeicherte Symbol mit den drei Möglichkeiten abgleicht. Danach wird geprüft, ob das Symbol für die jeweiligen erzeugten Zahlen korrekt ist. Wenn dies der Fall ist, wird der Rahmen des Symbolfeldes grün und nach einer Sekunde weiß. Danach werden die Objekte gelöscht und eine neue Runde wird geladen. Wenn das Kind die falsche Wahl getroffen hat, wird das Feld rot und die Fehleranzahl um eins hochgezählt. Nach einer Sekunde werden die Buttons wieder aktiviert und die Farbe des Rahmens zurückgesetzt. Das Symbolfeld wird wieder geleert und das Kind kann erneut versuchen das Problem zu lösen.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs EnableButtons-Funktion}]
	public void EnableButtons(){
		lessBtn.interactable = true;
		equalsBtn.interactable = true;
		greaterBtn.interactable = true;
	}
\end{lstlisting}
Diese Funktion aktiviert alle drei Buttons und wird aufgerufen nachdem das Kind den falschen Button ausgewählt hat.
\subsection{Szene - Rechenmauer}
\subsubsection{Rechenmauer - Design}
\graphic{bottom5Tiles}{Rechenmauer mit fünf Steinen unten}
Die Rechenmauer kann in drei verschiedenen Varianten gespielt werden. Je nach dem Schwierigkeitsgrad, wird diese mit fünf, vier oder drei Steinen in der untersten Reihe erzeugt. Im Header ist die Szene wie die anderen aufgebaut. In der Mitte wird die Mauer angezeigt, für welche ein Prefab eines Steines angelegt wurde, dieses wird dann mithilfe einer \textif{Layout Group} an die richtige Position gesetzt. Die Felder, die die unterste Reihe bilden, werden deaktiviert, damit der Nutzer diese nicht verändern kann. Wenn das Kind den Test Button drückt, werden die richtigen Felder auch deaktiviert, damit diese nicht wieder verfälscht werden können. Die falschen Steine werden geleert und das Kind muss die Lösung erneut eintragen. Dies ist in der Abbildung 5.30 zu sehen.\\
\graphic{rechenmauerRichtigUndFalsch}{ Richtig und falsch gelöste Steine}
Wenn der Schüler/die Schülerin die Rechenmauer komplett richtig gelöst hat, wird das anhand des Feuerwerks, das um den Test Button auftaucht angezeigt. Die Pyramide wird geleert und eine neue unterste Reihe wird erzeugt. Das Feuerwerk wird auch in dem Spiel "Führe die Reihe fort"\ angewendet und ist in Abbildung 5.31 zu sehen.
\graphic{finisheTriangle}{Feuerwerk nach richtigem Lösen}
\subsubsection{Rechenmauer - Skript}
\begin{lstlisting}[language=csh, caption={Triangle.cs Variablen-Deklaration}]
public class Triangle : MonoBehaviour
{

	public GameObject brick;

	//rows of the triangle
	public GameObject triangleGameObject;

	public Text lvlText;


	private GameObject spawnedObject;

	public GameObject leftFirework;
	public GameObject rightFirework;

	public GameObject fireworkPrefab;

	//3 = bottom 3 bricks, 4 = bottom 4 bricks, 5 = bottom 5 bricks
	private int triangleSize = 3;

	private int[][] jaggedSolution = new int[5][];

	private InputField[][] jaggedInputs = new InputField[5][];

	private int[] bottomNumbers;

	public Button testSolution;
	public Button menu;

	private int lvlCounter = 0;
	private int wrongChoice = 0;
	private int lvlNumber = 10;
	private int maxNumber = 0;
	private Vector3 scaleSize = new Vector3 (1.0f, 1.0f, 1.0f);
\end{lstlisting}
Im Skript der Rechenmauer benötigen wir eine Variable für das Prefab des einzelnen Steines. Die Rechenmauer wird in einer \textit{Layout Group} gespawnt, welche sich in einem Leeren Objekt befindet. Es gibt auch hier wieder ein Textfeld, um das aktuelle Level anzuzeigen und ein Objekt, in das die Blöcke erzeugt werden. Für das Feuerwerk werden auch ein Objekt und zwei Positionen benötigt. Für die einzelnen Reihen gibt es zweidimensionale Arrays, um die Lösung zu berechnen und um die Eingaben zu speichern. In der Szene gibt es zwei Buttons. Zum Abschluss benötigen wir noch private Variablen, die notwendig sind um das Level auszuführen. Diese wären ein Zähler für das Level, ein Zähler für die Fehler, die Anzahl an Leveln, die maximal größte Zahl und ein Vektor um die Steine zur Originalgröße zu skalieren.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs Start-Funktion}]
	void Start()
	{
		menu.onClick.AddListener(() => GoBack());
		maxNumber = MenuPickLevelAdvanced.maxNumberStatic;
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		triangleSize = MenuPickLevelAdvanced.wallSize;
		testSolution.interactable = false;
		testSolution.onClick.AddListener(() => CheckSolution());
		jaggedInputs[0] = new InputField[1];
		jaggedInputs[1] = new InputField[2];
		jaggedSolution[0] = new int[1];
		jaggedSolution[1] = new int[2];
		GenerateSolutionArray();
		SpawnPyramidRows();
		PlayGame();
	}
\end{lstlisting}
Die Start-Funktion weißt den Buttons den Listener zu und deaktiviert den Test-Button. Die Spitze und die zwei Felder der Mauer, die unter dem obersten Stein liegen, werden immer erzeugt, da diese immer verwendet werden. Die zweidimensionalen Arrays werden an der ersten und zweiten Stelle in der richtigen Größe initalisiert. Danach wird die Funktion \textit{GenerateSolutionArray()} aufgerufen, diese initailisert die restlichen Ebenen des Lösungsarrays und des Eingabearrays. Nachdem das Lösungsarray generiert wurde, werden die Reihen der Pyramide in die Szene geladen. Am Schluss wird die Funktion \textit{PlayGame()} aufgerufen, diese startet das Spiel für die Kinder.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs Update-Funktion}]
	void Update(){
		bool enabel = false;
		for (int i = 0; i < triangleSize - 1; i++){
			for (int j = 0; j < jaggedInputs[i].Length; j++) {
				if(string.IsNullOrEmpty(jaggedInputs[i][j].text)){
					enabel = true;
					testSolution.interactable = false;

				}
			}
		}
		if(!enabel){
			testSolution.interactable = true;
		}
	}
\end{lstlisting}
In dem Skript für die Rechenmauer und in dem für "Führe die Reihe fort"\, wird die Update-Funktion genutzt, um zu überprüfen ob alle Eingabefelder gefüllt sind. Wenn eines der Felder leer ist, wird der Test-Button nicht aktiviert. In anderen Szenen wurde dies mit der Funktion \textit{onValueChanged} gelöst, aber um mehrere Felder zu überprüfen ist die Variante in der Update-Funktion angenehmer. In diesem Skript läuft in der Update-Funktion eine doppelte \textit{for}-Schleife durch. Diese läuft für jede Zeile die Länge ab und kontrolliert ob eines der Felder leer ist. Wenn ein Feld leer ist, wird die \texit{boolean} Variable auf \textit{true} gesetzt, solange diese nicht \textit{false} ist, wird der Test-Button nicht aktiviert.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs GenerateSolutionArray-Funktion}]
	public void GenerateSolutionArray(){
		if(triangleSize >= 3){
			jaggedSolution[2] = new int[3];
			jaggedInputs[2] = new InputField[3];
			if(triangleSize >= 4){
				jaggedSolution[3] = new int[4];
				jaggedInputs[3] = new InputField[4];
				if(triangleSize == 5){
					jaggedSolution[4] = new int[5];
					jaggedInputs[4] = new InputField[5];
				}
			}
		}
	}
\end{lstlisting}
In dieser Funktion wird kontrolliert, welche Größe die unterste Reihe der Pyramide hat. Je nach der Größe werden die einzelnen Ebenen des zweidimensionales Arrays mit der passenden Größe deklariert. Zeitgleich wird das Array für die Eingaben des Kindes erzeugt, somit sind die beiden Arrays gleich groß.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs ShowBottomLineNumbers-Funktion}]
	public void ShowBottomLineNumbers(){
		for (int i = 0; i < bottomNumbers.Length; i++){
			if(triangleSize == 3){
				jaggedSolution[2][i] = bottomNumbers[i];
				jaggedInputs[2][i].text = bottomNumbers[i].ToString();
				jaggedInputs[2][i].interactable = false;
			}
			else if(triangleSize == 4){
				jaggedSolution[3][i] = bottomNumbers[i];
				jaggedInputs[3][i].text = bottomNumbers[i].ToString();
				jaggedInputs[3][i].interactable = false;
			}
			else if(triangleSize == 5){
				jaggedSolution[4][i] = bottomNumbers[i];
				jaggedInputs[4][i].text = bottomNumbers[i].ToString();
				jaggedInputs[4][i].interactable = false;
			}
		}
\end{lstlisting}
In dieser Funktion wird die unterste Reihe gefüllt. Es gibt drei \textit{If}-statements, die die breite der Mauer in der untersten Reihe überpüfen. Diese statements befinden sich in einern \textit{for}-Schleife und füllen je nach breite die Unterste reihe mit den zufällig generierten Zahlen auf. Die Funktion dafür wird später erklärt. Die Nummer aus dem Array wird auch sofort in das Eingabearray eingefügt, da diese Reihe für Kinder nicht bearbeitbar ist, aber die Kontrolle zwischen dem Eingabearray und dem Lösungsarray so einfacher ist. Jedes Feld aus dem Eingabearray, in dem eine Zahl aus der untersten Reihe steht, wird deaktiviert.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs FillSolutionArray-Funktion}]
	public void FillSolutionArray(){
		for (int i = triangleSize - 2; i >= 0; i--){
			for (int j = 0; j < jaggedSolution[i].Length; j++){
				jaggedSolution[i][j] = jaggedSolution[i + 1][j] + jaggedSolution[i + 1][j + 1];
			}
		}
	}
\end{lstlisting}
In dieser Funktion werden die Lösungen berechnet und an die richtige Position gespeichert. Dafür werden zwei \textit{For}-Schleifen benötigt. Um die Lösung zu berechnen, werden zwei nebeneinaderliegende Felder verwendet. Die äußere \textit{for}-Schleife zählt die Variable i nach unten, die innere zählt nach oben. Dies wurde so implementiert, da die Pyramide von unten nach oben berechnen werden müssen. Deswegen wurde i mit der Pyramidengröße - 2 belegt, weil die Schleife bis zur Zahl Null durchlaufen muss und weil die unterste Reihe schon gefüllt ist. Die zweite Schleife, geht die einzelnen Reihen durch und berechnet die Lösungen.\\
Die Funktion, die für den Test-Button aufgerufen wird, steht in einer Zeile, diese startet die \textit{Coroutine}, um die Ergebnisse zu überprüfen.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs PlayGame-Funktion}]
	public void PlayGame(){
		lvlCounter++;
		if(lvlCounter > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", wrongChoice);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + wrongChoice);
		}
		if(lvlCounter != 1){
			Debug.Log("hier war ich");
			ClearArray();
		}
		if(lvlCounter <= lvlNumber)	lvlText.text = "Level: " + lvlCounter + "/" + lvlNumber;
		GenerateNumbers();
		ShowBottomLineNumbers();
		FillSolutionArray();
	}
\end{lstlisting}
Diese Funktion zählt einen Zähler nach oben, um zu sehen welches Level das Kind spielt, um die Szene nach Abschluss des Spieles zu laden. Wenn der Zähler größer als die Zahl Eins ist, wird die Mauer mit jedem Aufruf der PlayGame-Funktion geleert. Wenn der Zähler kleiner als die maximale Anzahl an Leveln ist, wird das Textfeld aktualisiert und die zufälligen Zahlen werden erzeugt. Danach wird die unterste Reihe gefüllt und das Lösungsarray berechnet.\begin{lstlisting}[language=csh, caption={Triangle.cs ClearArray-Funktion}]
	public void ClearArray(){
		for (int i = 0; i < triangleSize - 1; i++){
			for (int j = 0; j < jaggedInputs[i].Length; j++) {
				jaggedInputs[i][j].text = "";
				jaggedInputs[i][j].interactable = true;
			}
		}
	}
\end{lstlisting}
Um das Array zu leeren, wird mithilfe einer doppelten \textit{for}-Schleife jedes Feld der Mauer durchgegangen, diese werden anschließend geleert und wieder aktiviert, sodass das Kind diese wieder füllen kann.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs SpawnPyramidRows-Funktion}]
	public void SpawnPyramidRows(){
		for (int i = 0; i < triangleSize; i++){
			for (int j = 0; j < i + 1; j++){
				spawnedObject = Instantiate(brick, triangleGameObject.transform.position, Quaternion.identity);
				spawnedObject.name += i;
				spawnedObject.transform.SetParent(triangleGameObject.transform.GetChild(i));
				spawnedObject.transform.localScale = scaleSize;
				jaggedInputs[i][j] =spawnedObject.GetComponent<InputField>();
			}
		}
	}
\end{lstlisting}
Um die Reihen der Mauer zu erzeugen, wird wieder eine doppelte \textit{for}-Schleife benötigt. Diese läuft die Variable \textit{triangleSize} durch und fügt in jedes freie Feld der \textit{Layout Group} einen Stein ein. Das Erzeugen der Mauer läuft nach dem gleichen Prinzip ab nachdem die Objekte bei den Mengenvergleichen oder bei dem Spiel Blitzblick erzeugt werden. Erst werden diese instantiiert, dafür wird das \textit{GameObject} des Steines benötigt. Danach wird ein Feld benötigt, in welches der Stein gesetzt werden soll, hierbei ist die Rotation wieder unwichtig. Die Objekte bekommen für die Hierarchie einen Namen und werden an die passende Kinderposition gesetzt. Da die Steine zu klein skaliert werden, wird die Skalierung auf eins zurückgesetzt. Als Letztes werden die Prefabs der Eingabefelder in das Array aus Eingabefeldern eingefügt.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs GenerateNumbers-Funktion}]
	public void GenerateNumbers(){
		bottomNumbers = new int[triangleSize];
		for (int i = 0; i < bottomNumbers.Length; i++) {
			bottomNumbers[i] = UnityEngine.Random.Range(0, maxNumber);
			jaggedSolution[triangleSize - 1][i] = bottomNumbers[i];
		}
	}
\end{lstlisting}
Diese Funktion deklariert die Größe eines normalen Arrays, welches die Größe der untersten Reihe beinhaltet. In einer \textit{for}-Schleife wird für jedes Feld in diesem Array eine zufällige Zahl mit der UnitEngine.Random.Range-Funktion generiert. Diese wird in die unterste Reihe des Arrays, das alle Lösungen speichert, eingefügt.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs SpawnFirework-Funktion}]
	public void SpawnFirework(){
		spawnedObject = Instantiate(fireworkPrefab, leftFirework.transform.position, leftFirework.transform.rotation);
		spawnedObject.transform.SetParent(leftFirework.transform);
		spawnedObject.transform.localScale = scaleSize;
		spawnedObject = Instantiate(fireworkPrefab, rightFirework.transform.position, rightFirework.transform.rotation);
		spawnedObject.transform.SetParent(rightFirework.transform);
		spawnedObject.transform.localScale = scaleSize;
	}
\end{lstlisting}
In dieser Funktion werden die Prefabs des Feuerwerks erzeugt. Dafür werden die Objekte so wie in den anderen Skripten erzeut. Der Unterschied hierbei ist, das das Feuerwerk eine Rotation benötigt um nicht gerade aufzutauchen. Daher werden aus den Bereichen links und rechts um den Test-Button die Werte der Rotation genommen und das Feuerwerk Objekt rotiert. Um an die Werte zu kommen, wird \textit{leftFirework.transfom.rotation} aufgerufen. Die beiden Feuerwerk Objekte wurde auch in diesem Fall wieder zu klein Skaliert und müssen auch wieder auf die Originalgröße skaliert werden.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs DeleteFirework-Funktion}]
	public void DeleteFirework(){
		Destroy(leftFirework.transform.GetChild(0).gameObject);
		Destroy(rightFirework.transform.GetChild(0).gameObject);
	}
\end{lstlisting}
Damit das Feuerwerk nach einer Sekunde wieder verschwindet, wird die Funktion \textit{DeleteFirework} aufgerufen. Diese löscht aus den beiden eigentlich leeren Objekten \textit{leftFirework} und \textit{rightFirework} die Prefabs der Feuerwerke.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs Waiter-Coroutine}]
	IEnumerator Waiter(int sec){
		bool finished = false;
		if(lvlCounter <= lvlNumber){
			for (int i = triangleSize - 2; i >= 0; i--){
				for (int j = 0; j < jaggedSolution[i].Length; j++){
					if(jaggedSolution[i][j] == int.Parse(jaggedInputs[i][j].text)){
						jaggedInputs[i][j].interactable = false;
						continue;
					}
					else{
						jaggedInputs[i][j].text = "";
						wrongChoice++;
						finished = true;
					}
				}
			}
			if(!finished){
				SpawnFirework();
				yield return new WaitForSeconds(sec);
				DeleteFirework();
				PlayGame();
			}
		}
	}
\end{lstlisting}
Hier wird überprüft, ob die Mauer komplett richtig gerechnet wurde. Dafür wird eine boolean Variable benötigt, diese ist standardmäßig mit \textit{false} implementiert. Nachdem die Funktion getestet hat, ob das Kind noch nicht alle Level gespielt hat, wird mit einer doppelten \textit{for}-Schleife überprüft, ob die Eingabe des Kindes die gleiche ist wie die Zahlen in dem Lösungsarray. Wenn ein Ergebnis richtig ist, wird das Eingabefeld deaktiviert und die Schleife springt einen Durchgang weiter. Wenn eine der Eingaben nicht richtig ist, wird das Feld geleert, der Fehlerzähler wird eins nach oben gezählt und die Variable \textit{finished} wird auf \textit{true} gesetzt. Wenn die Variable \textit{false} ist, wurde die gesamte Mauer gelöst, also wird das Feuerwerk mit dem Aufruf der Funktion \textit{SpawnFirework()} erzeugt. Dann wartet das Skript mithilfe des \textit{yield return new WaitForSeconds(sec)} eine Sekunde. Danach wird das Feuerwerk mit der Funktion \textit{DeleteFirework()} gelöscht. Als Letztes wird die Funktion \textit{PlayGame()} aufgerufen und damit eine neue Mauer generiert.\\
\subsection{Szene - Blitzblick}
\subsubsection{Blitzblick - Design}
\graphic{lightningViewWithoutCover}{Blitzblick ohne Vorhang}
\graphic{lightningViewCover} Blitzblick mit Vorhang}
Die Szene ist hier in zwei Bildern gezeigt. In der Abbildung 5.32 ist die Szene ohne den Vorhang zu sehen und in der Abbildung 5.33 mit dem Vorhang. Das Spiel Blitzblick, zeigt dem Schüler/der Schülerin, eine Anzahl an Objekten und verdeckt diese danach. Das Kind, muss dann sehr schnell sehen, wie viele der Objekte angezeigt wurden und diese in ein Textfeld eingeben. Wenn das Kind den Testbutton auswählt wird die Zahl überprüft und wenn es richtig lag wird eine neue Runde geladen. Wenn das Kind die falsche Anzahl angibt, bekommt es die Objekte noch einmal für eine Sekunde zu sehen. Die Zeit, wie lange die Objekte zu sehen sind, wird nicht verringert oder erhöht, da eine Sekunde für die vorhergesehen Anzahl an Objekten schon schwer ist.\\
Die Szene hat einen Header wie jede andere, in diesem ist ein Menü Button, eine Überschrift und die Levelanzahl zu sehen. In der Mitte der Szene ist das Feld, indem die Objekte auftauchen, dieses wird von einem grünen Vorhang verdeckt. Rechts davon ist das Eingabefeld für den Nutzer. Ganz unten in der Szene ist der Button zum Testen seiner Lösung. Dieser ist, solange keine Zahl eingegeben wurde, deaktiviert. In dieser Szene wird dem Schüler/der Schülerin durch einen grünen Rahmen angezeigt, ob die Lösung richtig oder falsch ist.\\
\subsubsection{Blitzblick - Skript}
\begin{lstlisting}[language=csh, caption={lightningView.cs Variablen Deklaration}]
public class lightningView : MonoBehaviour {

	public Text showLevel;

	public InputField solution;

	public Image imageColor;

	public GameObject spawnedObject;
	public GameObject spawner;
	public GameObject cover;
	private GameObject allObjects;

	public GameObject spawnerCoverLeft;

	public Button checkButton;
	public Button menu;

	private List<Vector2> allPositions = new List<Vector2>(10);

	//Variabln for lightningView
	private int numberLeft;
	private int counterRound = 0;
	private int wrongChoice = 0;
	private int lvlNumber = 10;
	private float minDistance = 0f;
	private bool hitPosition = false;
	private Vector3 scaleSize = new Vector3 (1.0f, 1.0f, 1.0f);
\end{lstlisting}
Für dieses Spiel benötigen wir wieder ein Textfeld, um das Level anzuzeigen. Die Szene benötigt, auch ein Eingabefeld und ein Objekt, um die Farbe des Rahmens zu ändern. Da in diesem Skript wieder Objekte erzeugt werden, wird ein Bereich in denen diese auftauchen sollen, festgelegt. In Unity wurde ein Prefab der Objekte vorbereitet. Damit der Vorhang über den Objekten zu sehen ist, wird dieser auch durch ein Prefab geladen. In diesem Skript werden die Objekte an zufälligen Positionen erzeugt, damit diese nicht aufeinander liegen, wird die position in eine Vektor-Liste eingespeichert. Um das Spiel zu managen, werden ein paar \textit{private} Attribute benötigt. Um zu unterscheiden, wie groß die minimal Distanz sein soll, wurde eine Variable deklariert. Um eine Überschneidung zu finden, benötigt das Skript eine Boolean variable. Die Objekte werden auch in diesem Fall wieder zu klein skaliert, deswegen wird wieder ein Vektor mit der Standartgröße festgelegt\\
\begin{lstlisting}[language=csh, caption={lightningView.cs Start-Funktion}]
	void Start() {
		minDistance = spawnedObject.GetComponent<RectTransform>().rect.width / 2;
		spawner.transform.localScale = scaleSize;
		checkButton.interactable = false;
		menu.onClick.AddListener(() => GoBack());
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		checkButton.onClick.AddListener(() => buttonClick());
		solution.onValueChanged.AddListener(delegate {EnableButton(); });
		playGame();
	}
\end{lstlisting}
Diese \textit{Start} Funktion, legt als Erstes die minimale Distanz fest, die ein Objekt zu einem anderen Objekt besitzen darf. Diese wird wie folgt berechnet. Das Skript holt sich von dem Prefab Objekt \textit{spawnedObject} ein Rechteck. Der befehlt \textit{.GetComponent<RectTransform>().rect.width} sucht sich aus dem Prefab das Rechteck und nimmt von diesem die Breite. Die minimale Distanz zwischen den Objekten ist die Hälfte des bekommenen Rechtecks. Danach wird der Bereich für die Objekte auf die Originalgröße skaliert, da dieser nicht mit skaliert wurde. Das heißt, im Vollbildmodus wurde dieser nicht größer. Der Testbutton wird wieder deaktiviert. In dieser Szene werden von den statischen Variablen, nur die Levelanzahl verwendet. Das Feld der Objekte kann nur eine gewisse Anzahl an Objekten beinhalten und diese Zahl darf auch für die Kinder nicht zu groß werden. Um zu überprüfen, ob das Kind etwas in das Eingabefeld eingegeben hat, wird die \textit{onValueChange} Methode verwendet. Als Letztes wird die \textit{playGame()} aufgerufen.\\
Die nächsten zwei Funktionen des Skriptes, laden das Menü und Aktivieren oder Deaktivieren den Test Button, diese sind ähnlich und werden deswegen nicht mehr genauer erläutert.\\
\begin{lstlisting}[language=csh, caption={lightningView.cs buttonClick-Funktion}]
	public void buttonClick(){
		checkButton.interactable = false;
		foreach (Transform child in spawnerCoverLeft.transform) {
			Destroy(child.gameObject);
		}
		StartCoroutine(solutionWaiter(1));
	}
\end{lstlisting}
Diese Funktion wird beim Aufruf des Testbuttons durchlaufen, da in dieser Szene über den Objekten ein Vorhang schwebt, wird dieser einmal gelöscht und die \textit{Coroutine}, die die Lösung überprüft wird aufgerufen.\\
Auch die Funktion für die Zufallszahlen wird nicht genauer erklärt. In diesem Spiel wurde die maximale Zahl auf die zehn gesetzt. Da mehr Objekte das Feld nicht beinhalten können und Kinder nicht zu viele Objekte in so kurzer Zeit erkennen können.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs buttonClick-Funktion}]
	public void hideCircle(){
		StartCoroutine(waiter(1));
	}
	
	IEnumerator waiter(int sec){
		solution.interactable = false;
		yield return new WaitForSeconds(sec);
		GameObject hideCircles = Instantiate(cover, spawnerCoverLeft.transform.position, Quaternion.identity);
		hideCircles.transform.SetParent(spawnerCoverLeft.transform);
		hideCircles.transform.localScale = scaleSize * (0.75f);
		solution.interactable = true;
	}
\end{lstlisting}
Um den Vorhang nicht direkt am Anfang zu erzeugen, wird eine weiter \textit{Coroutine} geladen, diese deaktiviert das Eingabefeld für den Nutzer so lange bis der Vorhang aufgetaucht ist, dies hat den Vorteil, dass der Nutzer nicht schon direkt die Zahl eintragen kann, sondern wirklich eine Sekunde warten muss. Danach wird wie in anderen Szenen das Objekt erzeugt. Da der Vorhang aber erst zu klein war und in der Originalgröße zu groß ist, wird diese mit 0.75 multipliziert.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs setObjects-Funktion}]
	public void setObjects(){
		Debug.Log(numberLeft);
		for (int i = 0; i < numberLeft; i++) {
			allObjects = Instantiate(spawnedObject, spawner.transform.position, Quaternion.identity);
			allObjects.name += i;
			allObjects.transform.SetParent(spawner.transform);
			allObjects.transform.localScale = scaleSize;
			ChangePosition(i);
		}
	}
\end{lstlisting}
Hier werden für die zufällig generierte Zahl die Objekte mithilfe einer \textit{For}-Schleife generiert. Diese werden auf die normale Größe skaliert und danach wird die Funktion \textit{ChangePosition(i)} aufgerufen.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs ChangePosition-Funktion}]
	public void ChangePosition(int firstNumber){
		RectTransform spawnRect = spawner.GetComponent<RectTransform>();
		float width = spawnRect.rect.width;
		float height = spawnRect.rect.height;
		float xPos = UnityEngine.Random.Range(-width/2 + minDistance, width/2 - minDistance);
		float yPos = UnityEngine.Random.Range(-height/2 + minDistance, height/2 - minDistance);
		Vector2 newPos = new Vector2(xPos, yPos);
		Debug.Log("x:" + xPos);

		if(firstNumber == 0){
			allPositions.Add(newPos);
			allObjects.transform.localPosition = newPos;
			return;
		}


		for (int i = 0; i < allPositions.Count; i++){
			float distance = Vector2.Distance(new Vector2(allPositions[i].x, allPositions[i].y), new Vector2(newPos.x, newPos.y));
			if(distance >= minDistance){
				hitPosition = true;
			}
			else{
				hitPosition = false;
				break;
			}

		}
		if(hitPosition){
			allPositions.Add(newPos);
			allObjects.transform.localPosition = newPos;

		}
		else{
			ChangePosition(firstNumber);
		}

	}
\end{lstlisting}
Hier wird eine zufällige Position in dem Rechteck \textit{spawner} erzeugt. Dafür, bekommt ein Objekt \textit{RectTransform} das Rechteck des \textit{spawner}. Von diesem Objekt werden die breite und Höhe in Variablen gespeichert. Dann wird für die X-Position und Y-Position eine Random Zahl erzeugt. Die X-Position wird aus der Breite berechnet. Die kleinste mögliche Zahl befindet sich an der Stelle \textit{-width/2 + minDistance}, die maximale Zahle befindet sich an der Stelle \textit{width/2 - minDistance}. Es muss die negative breite geteilt durch zwei sein, da das Skript vom Mittelpunkt des Objektes ausgeht, also muss erst die breite geteilt werden und danach ist die negative zahl davon ganz links. Damit das Objekt nicht auf dem Rand des Rechtecks spawnend, wird die minimale Distanz der Objekte darauf gerechnet. Für den ganz rechten Rand des Rechtecks wird die positive Breite geteilt und minus die minimale Distanz gerechnet. Für die Y-Position wird die gleiche Rechnung benötigt. Nur dass anstatt der breite die höhe des Rechtecks verwendet wird. Nachdem die beiden Positionen zufällig erzeugt wurden, werden diese in einen Vektor gespeichert. Wenn die Übergabe variable eine null ist, also wenn die \textit{For}-Schleife bei dem ersten durchlaufen ist, wird die Position, die im Vektor \textit{newPos} gespeichert wurde, in eine Liste gespeichert. Danach wird das Objekt an diese Position bewegt und die Funktion mithilfe des Befehls \textit{return} verlassen.\\
Wenn das nicht der erste Durchlauf ist, wird mithilfe einer \textit{For}-Schleife, für das aktuelle Objekt zuerst die Distanz zwischen allen Objekten und der neuen Position berechnet. Die Methode \textit{.Distance} bekommt zwei Vektoren, mit den X und Y werden der Position übergeben und berechnet einen Vektor der die Distanz beinhaltet. Wenn die Distanz dann größer oder gleich unsere minimal Distanz ist, wurde eine Position gefunden, die genutzt werden kann, um das Objekt zu platzieren. Wenn das nicht der Fall ist, wird die Boolean Variable auf false gesetzt und die Schleife verlassen. In diesem Fall wird durch eine Abfrage die Funktion \textit{ChangePosition(firstNumber)} erneut aufgerufen. Wenn die Variable \textit{hitPosition} true ist, wird die neu gefundene Position in die Liste gespeichert und das Objekt an die besagte Position bewegt.\\
Die Funktion, die die Objekte wieder löscht, ist dieselbe, die die Objekte in dem Spiel größer, kleiner, gleich löscht. Diese geht mithilfe einer \textit{foreach}-Schleife alle Objekte durch und löscht diese.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs playGame-Funktion}]
	public void playGame(){
		counterRound++;
		if(counterRound > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", wrongChoice);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + wrongChoice);
		}
		//change color to white
		imageColor.color = new Color32(255, 255, 255, 255);
		if(counterRound <= lvlNumber)	showLevel.text = "Level: " + counterRound + "/" + lvlNumber;
		numberLeft = randomNumber();
		Debug.Log(numberLeft);
		solution.text = "";
		setObjects();
		hideCircle();
	}
\end{lstlisting}
Die Funktion \textit{playGame} arbeitet ähnlich zu den anderen, zuerst wird der Level Zähler hochgezählt und getestet, ob das Kind noch Level spielen sollte. Wenn nicht, wird die Szene für den Abschluss geladen. Die Farbe des Rahmens wird wieder auf Weiß gesetzt und ein neues Level wird generiert. Dafür muss das Eingabefeld geleert werden und neue Objekte zufällig erzeugt werden. Als Abschluss, muss der Vorhang wieder auftauchen.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs solutionWaiter-Funktion}]
	IEnumerator solutionWaiter(int sec){
		solution.interactable = false;
		if(counterRound <= lvlNumber){
			if(int.Parse(solution.text) == numberLeft){
				//change color green
				imageColor.color = new Color32(37, 250, 53, 255);
				yield return new WaitForSeconds(sec);
				deletObjects();
				playGame();

			}
			else{
				//change color red
				imageColor.color = new Color32(251, 37, 37, 255);
				yield return new WaitForSeconds(sec);
				wrongChoice++;
				//change color to white
				imageColor.color = new Color32(255, 255, 255, 255);
				solution.text = "";
				hideCircle();
			}
		}
	}
\end{lstlisting}
Diese \textit{Coroutine} deaktiviert das Eingabefeld und überprüft, ob die eingeben Zahl dieselbe ist, wie die zufällig generierte. Wenn das der Fall ist, wird der Rahmen grün und nach einer Sekunde werden die Objekte gelöscht und eine neue Runde mit der \textit{playGame()} Funktion gestartet. Wenn das Kind falsch liegt, wird der Rahmen für eine Sekunde rot und danach wieder weiß, das Eingabefeld wird geleert und die Objekte werden wieder versteckt.
\subsection{Szene - Vervollständigen die Reihe}
\subsubsection{Vervollständigen die Reihe - Design}
\graphic{finishPattern}{Verfolständige die Reihe}
In dieser Szene muss das Kind eine vorgegebene Reihe erkennen und fortführen. Den Kindern werden fünf Zahlen vorgegeben und aus dieser Reihe müssen sie die Schritte, die die Zahlen machen, erkennen und anwenden. Die Szene hat einen Header der gleich aufgebaut ist wie in den anderen Szenen. In der Mitte der Szene befinden sich insgesamt zehn Feldern, in der oberen Reihe, sind dies fünf Textfelder. Diese zeigen die Reihe an. In der unteren Reihe, befinden sich fünf Textfelder, die den Platzhalter Zahl haben. In diese können die Kinder ihre Zahlen eingeben. Der Testbutton wird auch in dieser Szene erst aktiviert, wenn alle Eingabefelder eine Zahl beinhalten. Diese Felder können keine anderen Zeichen als Zahlen enthalten. Dem Schüler/der Schülerinnen, wird auch in dieser Szene anhand eines Feuerwekes gezeigt, ob es alle Felder richtig ausgefüllt hat. In Abbildung 5.31 ist das erwähnte Feuerwekt zu sehen. Das Spiel wurde so implementiert, dass eine zufällige Zahl erzeugt wird und mit zwei weiteren Zufallszahlen die Reihe fortgesetzt wird. Es wurde sich gegen noch mehr Zufallszahlen entschieden, damit die Schüler/Schülerinnen keine zu komplexen Reihen bekommen. Es wurde aber so implementiert, dass in den unterschiedlichen Schwierigkeitsgraden die Anfangszahl größer werden kann und auch die Zahlen, die die Reihe Fortzusetzen werden größer.
\subsubsection{Vervollständigen die Reihe - Skript}
\begin{lstlisting}[language=csh, caption={hideCircle.cs Variablen Deklaration}]
public class FinishPattern : MonoBehaviour {

	public Text lvlText;

	//random Numbers
	private int randomNumber;
	private int FirstRandomNumber;
	private int SecondRandomNumber;

	//lvl variabls
	private int lvlNumber = 10;
	private int wrongAnswers;
	private int lvlCounter = 0;
	private int maxNumbers = 20;

	//int start start pattern
	private int[] patternNumbers = new int[5];

	//int solutions
	private int[] solutionsNumbers = new int[5];


	//Button test
	public Button checkSolution;
	public Button menu;

	//Firework
	private GameObject spawnedObject;
	public GameObject leftFirework;
	public GameObject rightFirework;
	public GameObject fireworkPrefab;

	public InputField[] arrayInputs = new InputField[5];
	public Text[] arrayTextFields = new Text[5];
\end{lstlisting}
Für dieses Spiel werden mehr er zufällige Zahlen benötigt. Eine um die Reihe zu starten und zwei um die Reihe fortzusetzen.  Es werden auch wieder Variablen benötigt, um das Spiel laufen zu lassen. Wie die Level Anzahl, die Fehleranzahl, die Anzahl an leveln und die Maximale größte Zahl. Für die Reihe und die Lösungen werden zwei Arrays deklariert. Diese bekommen die Größe Fünf. Die Szene benötigt zwei Objekte für die Buttons und die Objekte für das Feuerwerk. In dieser Szene wurden anfangs, die Objekte für die Eingaben der Kinder und die Textfelder Einzeln deklariert, in der aktuellsten Umsetzung wurden auch dafür zwei Arrays deklariert. Diese sind Public und somit können die einzelnen Objekte in Unity in das Skript von Hand eingefügt werden. Wie dies abläuft, ist in Abbildung 5.19 zu sehen.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs Start-Funktion}]
	void Start() {
		menu.onClick.AddListener(() => GoBack());
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		maxNumbers = MenuPickLevelAdvanced.maxNumberStatic;
		checkSolution.interactable = false;
		checkSolution.onClick.AddListener(() => clickButton());
		for (int i = 0; i < arrayInputs.Length; i++){
			arrayInputs[i].onValueChanged.AddListener(delegate { EnableButton(); });
		}
		PlayGame();
	}
\end{lstlisting}
In der \textit{Start}-Funktion werden die Listener für die Buttons deklariert. Die größte mögliche Nummer die zufällig erzeugt werden kann wird festgelegt und die Anzahl an leveln wird auch festgelegt. Der Test Button wird deaktiviert. Um eine andere Art der Überprüfung, ob ein Eingabefeld leer ist zu verwenden, wurde jedem der Eingabefelder über die Methode \textit{onValueChanged} ein Listener hinzugefügt. Diese Art ist zwar schon bekannt, wurde in diesem Teil des Projektes aber noch nicht mit einem Array aus Objekten verwendet. Als Letztes wurde die Funktion, die das Spiel startet und immer wieder neu erzeugt aufgerufen, die \textit{PlayGame}-Funktion.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs EnableButton-Funktion}]
	public void EnableButton() {
		if (string.IsNullOrEmpty(arrayInputs[0].text) || string.IsNullOrEmpty(arrayInputs[1].text) || string.IsNullOrEmpty(arrayInputs[2].text) || string.IsNullOrEmpty(arrayInputs[3].text) || string.IsNullOrEmpty(arrayInputs[4].text)) {
			checkSolution.interactable = false;
		} else {
			checkSolution.interactable = true;
		}
	}
\end{lstlisting}
Hier ist die Funktion zu sehen, die den Testbutton aktiviert oder deaktiviert. Da es mehrere Felder sind, können diese entweder mithilfe einer \textit{For}-Schleife abgefragt werden, diese würde dann durch alle Eingabefelder iterieren und überprüfen, ob an dieser Stelle eine Eingabe ist, wenn ja, könnte nach der gesamten Überprüfung der Testbutton aktiviert werden, wenn nicht, dann würde dieser deaktiviert bleiben. Da es aber mit der Schleife mehr Code wäre, wurde in einem \textit{If}-Statement mithilfe der Oder-Verknüpfung überprüft, ob eines der Felder leer ist. Wenn ja, wird der Button nicht aktiviert oder erneut deaktiviert, fals das Kind die Eingabe aus einem der Felder löscht. Wenn alle Felder gefüllt sind, wird in einer \textit{else} der Button aktiviert.\\
Die nächsten vier Funktionen des Skriptes, werden nicht gezeigt, diese werden einmal aufgerufen, wenn der Menüknopf gedrückt wird und wenn der Testknopf gedrückt wurde. Diese laden die Menü-Szene und starten die Abfrage, ob die eingegebene Lösung des Kindes richtig ist. Die letzten zwei Funktionen sind für die zufälligen Zahlen zuständig, die erste der beiden, erzeugt eine zufällige Zahl zwischen null und der maximal möglichen Zahl. Die andere wird später zweimal aufgerufen, um die Zahlen für das Muster zu erzeugen. Diese werden zwischen eins und der maximal möglichsten Zahl erzeugt. Der Grund dafür war, es wäre für die Kinder langweilig, wenn die Reihe sich um null erhöht. \\
\begin{lstlisting}[language=csh, caption={hideCircle.cs PlayGame-Funktion}]
	public void PlayGame() {
		lvlCounter++;
		if(lvlCounter > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", wrongAnswers);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + wrongAnswers);
		}
		ResetInputFields();
		if(lvlCounter <= lvlNumber)	lvlText.text = "Level: " + lvlCounter + "/" + lvlNumber;;
		randomNumber = RandomBeginningNumber(maxNumbers);
		FirstRandomNumber = RandomPatternNumbers();
		SecondRandomNumber = RandomPatternNumbers();
		SetStartPattern();
		SetSolution();
		SetPattern();
	}
\end{lstlisting}
Diese Funktion ist wieder ähnlich zu den andere, sie überprüft wie viele Level noch gespielt werden müssen und beendet das Spiel oder setzt es fort. Wenn das Kind noch spielen soll, wird der Text um das Level anzuzeigen aktualisiert. Die Eingabe Felder werden zurückgesetzt und die zufälligen Zahlen werden erzeugt und in die dazugehörige Variable gespeichert. Danach wird das Muster erzeugt und die daraus folgende Lösung berechnet. Als Letztes wird das Muster nur noch in die Textfelder geschrieben.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs SetStartPattern- und SetSolution-Funktion}]
	public void SetStartPattern() {
		patternNumbers[0] = randomNumber;
		patternNumbers[1] = patternNumbers[0] + FirstRandomNumber;
		patternNumbers[2] = patternNumbers[1] + SecondRandomNumber;
		patternNumbers[3] = patternNumbers[2] + FirstRandomNumber;
		patternNumbers[4] = patternNumbers[3] + SecondRandomNumber;
	}

	public void SetSolution() {
		solutionsNumbers[0] = patternNumbers[4] + FirstRandomNumber;
		solutionsNumbers[1] = solutionsNumbers[0] + SecondRandomNumber;
		solutionsNumbers[2] = solutionsNumbers[1] + FirstRandomNumber;
		solutionsNumbers[3] = solutionsNumbers[2] + SecondRandomNumber;
		solutionsNumbers[4] = solutionsNumbers[3] + FirstRandomNumber;
	}
\end{lstlisting}
Diese Funktionen könnten auch in einer Funktion stattfinden, wurde aber für die Übersichtlichkeit in zwei unterschiedlichen implementiert. Die \textit{SetStartPattern}-Funktion, speichert an die erste stelle die Start Zahl ein. Danach wird mithilfe der zwei andern Zufallszahlen, hier \textit{FirstRandomNumber} und \textit{SecondRandomNumber} genannt berechnet. Zuerst wird die erste Zahl darauf addiert, danach die zweite und so weiter. Nachdem das Muster berechnet wurde, wird die Funktion \textit{SetSolution} aufgerufen, diese berechnet die Lösung, die das Kind eintippen sollte. Dafür wird die letzte Zahl des Musters verwendet, auf diese wird die erste Zufallszahl addiert und danach auf das Ergebnis die zweite Zahl addiert. Das wird so lange wiederholt, bis das Array gefüllt ist.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs SetPattern-Funktion}]
	public void SetPattern() {
		for (int i = 0; i < arrayInputs.Length; i++){
			arrayTextFields[i].text = patternNumbers[i].ToString();
		}
	}
\end{lstlisting}
Diese Funktion iteriert mit einer \textit{For}-Schleife durch das Textfeld Array und weißt jedem der Felder die passende Nummer zu. Die Integerzahl wird auch hier wieder in einen String umgewandelt.\\
Die Funktionen um das Feuerwerk zu erzeugen und zu löschen, sind dieselben wie in dem Skript für die Rechenmauer.\\ %TODO nenne wo diese stehen
\begin{lstlisting}[language=csh, caption={hideCircle.cs Solution-Funktion}]
	IEnumerator Solution(int sec){
		bool skip = false;
		if (lvlCounter <= lvlNumber) {
			for (int i = 0; i < 5; i++) {
				if (solutionsNumbers[i] == int.Parse(arrayInputs[i].text)) {
					arrayInputs[i].interactable = false;
					continue;
				}
				else{
					skip = true;
					wrongAnswers++;
					arrayInputs[i].text = "";
				}
			}
			if (!skip) {
				SpawnFirework();
				yield return new WaitForSeconds(sec);
				DeleteFirework();
				PlayGame();
			}
		}
	}
\end{lstlisting}
Diese Funktion überprüft die Lösungen des Kindes. Dafür wird eine Boolean Variable benötigt. Danach wird mit einer \textit{For}-Schleife durch fünf Schritte iteriert. Da die Arrays eine feste Größe besitzen ist es möglich dort die fünf fest vorzugeben. In diesem Fall kann auch die Größe des Eingabearrays oder des Lösungsarrays verwendet werden. In der Schleife, werden die Eingaben des Schülers/der Schülerinnen mit denen aus dem Lösungsarray verglichen, sobald eine Zahl gleich ist, wird die Boolean Variable auf true gesetzt und die Schleife springt eine Iteration weiter. Wenn eine Eingabe nicht mit der Lösung übereinstimmt, wird die Boolean Variable auf true gesetzt und der Zähler für die Fehler wird um eins erhöht. Das dazugehörige Eingabefeld wird geleert, somit sollte das Kind wissen, dass dieses Feld nicht richtig gelöst war. Wenn die Variable \textit{skipt} am Ende der Schleife den wert false hat, sind alle Eingabefelder richtig gelöst. Daraufhin wird mithilfe der Funktion \textit{SpawnFirework} das Feuerwerk für den Nutzer erzeugt. Nach einer Sekunde wird dieses durch die Funktion \textit{DeleteFirework} wieder gelöscht. Als letzter Schritt des Skriptes wird die Funktion \textit{PlayGame} aufgerufen. \\
\begin{lstlisting}[language=csh, caption={hideCircle.cs ResetInputFields-Funktion}]
	public void ResetInputFields(){
		for (int i = 0; i < arrayInputs.Length; i++){
			arrayInputs[i].text = "";
			arrayInputs[i].interactable = true;
		}
	}
\end{lstlisting}
Diese Funktion löscht nach erfolgreichen Lösens der Reihe die Eingabe aus alle Eingabefeldern. Das wird mit einer \textit{For}-Schleife gelöst. Diese leert das Eingabefeld und aktiviert es für den Nutzer wieder.
\subsection{Szene - Wortsalat}
\subsubsection{Wortsalat - Design}
\graphic{wordMix}{Wortsalat}
Dies ist die einzige Szene, die ein Spiel beinhaltet, um die Sprache Deutsch zu verbessern. Die Szene hat einen Header, der sich nicht von den anderen unterscheidet. Dieser beinhaltet einen Menübutton, eine Überschrift und die Level Anzeige.\\
In der Mitte gibt es ein großes Rechteck, in diesem wird das Wort, das gemischt wird angezeigt. Dazwischen befindet sich das Bild eines Pfeiles. Dieser wurde aus dem Internet heruntergeladen und die Quelle befindet sich im Quellenverzeichnis.\\ %TODO quelle einfügen
Ganz rechts ist das Eingabefeld für den Nutzer. Ganz unten in der Mitte befindet sich der Button, um die Lösung zu überprüfen.
\subsubsection{Wortsalat - Skript}
Als Erstes wird auf die Datei die Wörter beinhaltet eingegangen. Um eine Liste mit vielen deutschen Wörtern zu bekommen, kann eine \textit{API} verwendet werden. Da aber sicher gegangen werden sollte, dass die Wörter für Kinder in der ersten bis vierten Klasse nicht zu anspruchsvoll sind und die Kinder diese Wörter auf jeden Fall kennen. Damit dies gewährleistet wurde, können auf der Website \textit{Grundschulkönig} können im Themenbereich Deutsch, eine Liste mit einem Grundwortschatz für die erste bis zweite  Klasse herunterladen\footnote{Grundschulkönig, (2022, o. S.)}. Es wurden keine Wörter für die dritte und vierte Klasse ausgewählt, da die Datei mit den ersten beiden Klassen sehr viele Worte beinhaltet. Diese Datei kann aber einfach erweitert werden. Im folgenden Abschnitt wird ein Teilausschnitt der Datei gezeigt. 
\begin{lstlisting}[language=csh, caption={Wort Datei}]
{
	"words": [
		"Abend",
		"Abende",
		"acht",
		"alle",
		"alles",
		"alt",
		"älter",
		"Ampel",
		"Apfel",
		"Äpfel",
		"April",
\end{lstlisting}
Die Datei ist angelegt wie eine JSON Datei und wurde auch mit der gleichen Endung abgespeichert. Das ermöglicht dem Skript darauf zuzugreifen wie als wäre es eine Tabelle in einer JSON Datenbank.\\
\begin{lstlisting}[language=csh, caption={WordMix.cs Variablen Deklaration}]
public class WordMix : MonoBehaviour
{

	public Text wordLeft;
	public Text lvlNumber;

	public InputField solutionChild;

	private string mixedWord;
	private string solution;
	public Image imageColor;

	private int lvlCount = 0;
	private int lvlAmount = 10;
	private int wrongChoices = 0;
	private int randomNumber = 0;

	//json file
	public TextAsset textJson;
	public WordList list = new WordList();

	//button
	public Button testWord;
	public Button menu;
\end{lstlisting}
Für die Szene werden Textfelder für das Level und das gemischte Wort benötigt. Es wird auch ein Eingabefeld für den Nutzer benötigt. Die Buttons für das Menü und das Testen werden ebenfalls auch benötigt. Es werden Variablen benötigt, die Anzahl an Level begrenzen und die Zufallszahl abspeichern. Die Level und die Fehler müssen auch gezählt werden. Das Skript muss die Lösung abspeichern und das gemischte Wort. Um mit der JSON Datei zu arbeiten, werden zwei Objekte benötigt. Eine \textit{WordList list} und ein \textit{TextAsset textJson} auf das \textit{TextAsset} Objekt, wird die Datei mit allen Wörtern zugewiesen. Dies ist zu sehen in Abbildung 5.36. \graphic{JsonFile}{JSON File in das Skript importieren}\\
Wie dann auf dieses File zugegriffen wird, wird später erklärt.\\
\begin{lstlisting}[language=csh, caption={WordMix.cs Start-Funktion}]
	void Start()
	{
		testWord.interactable = false;
		menu.onClick.AddListener(() => GoBack());
		lvlAmount = MenuPickLevelAdvanced.lvlAmmountStatic;
		testWord.onClick.AddListener(() => ButtonClicked());
		solutionChild.onValueChanged.AddListener(delegate {EnableButton(); });
		ReadJsonFile();
		PlayGame();
	}
\end{lstlisting}
Diese Funktion deaktiviert, den Test Button und fügt die Listener hinzu. Die Level Anzahl wird abgespeichert und eine Listener wird hinzugefügt, der sich bei einer Eingabe in das Eingabefeld aktiviert und eine Funktion aufruft, die testet, ob der Testbutton aktiviert werden soll oder nicht. Danach wird die Funktion aufgerufen, die unsere JSON Datei liest und die Worte daraus in eine Liste speichert. Als Letztes wird die Funktion \textit{PlayGame} aufgerufen und das Spiel wird initialisiert.\\
\begin{lstlisting}[language=csh, caption={WordMix.cs ReadJsonFile-Funktion}]
	public void ReadJsonFile(){
		list = JsonUtility.FromJson<WordList>(textJson.text);
	}
	[System.Serializable]
	public class WordList
	{
	public string[] words;
	}
\end{lstlisting}
Um daten aus einer JSON Datei zu lesen, wird eine extra Klasse benötigt, diese kann serialisiert werden, aber nicht vererbt. Das ist das Keyword \textit{System.Serializable}. Diese Klasse beinhaltet einen String Array \textit{words}. Um nun auf die Daten zu kommen, wird in die liste, die in den Variablen deklariert, wurde die listen aus der JSON Datei gespeichert. Dafür muss diese jedes Wort in einen String umwandeln und auch nur die einzelnen Wörter ausgeben. Mit \textit{JsonUtility.FromJson<WordList>textJson.text);} bekommt unser Skript ein Objekt der Klasse \textit{WordList}, dieses ist ein Array aus Wörtern. Diese können in unsere Liste gespeichert werden, darum ist egal, wie groß die Datei ist, die Liste wächst mit. Um auf die einzelnen Wörter aus der Datei zu kommen wird das Objekt das die Datei beinhaltet mit \textit{.text} aufgerufen, diese Methode gibt die einzelnen Wörter aus der Datei aus, diese werden in das Array \textit{words} gespeichert und dieses Array wird in eine Liste gespeichert. Daher hat das Skript nun eine Liste mit allen Wörtern, die in der Datei vorhanden sind.\\
Die Funktionen für den Menübutton und um den Test Button zu aktivieren, arbeiten gleich wie in den anderen Szenen, der Menü Button lädt die Szene des Menüs und setzt die Variablen. Die Funktion für den Testbutton überprüft nur das Eingabefeld und aktiviert oder deaktiviert diesen.\\
Die Funktion \textit{PlayGame} arbeitet gleich wie alle anderen, einmal den Zähler hochzählen und die Szene \textit{LearnFinishScreen} laden oder Szene für die nächste Runde vorbereiten. In dieser Szene wird wieder durch einen farbigen Rand angezeigt, ob das Kind richtig lag oder nicht. Das heißt, dieser Rahmen muss wieder auf die Farbe Weiß gesetzt werden. Danach wird wieder ein neues Wort aus der Liste geholt und gemischt. Als letztes, wird das Wort, wenn es gemischt wurde in das Textfeld links geschrieben.\\
\begin{lstlisting}[language=csh, caption={WordMix.cs GetWord-Funktion}]
	public void GetWord(){
		randomNumber = GetRandomNumbers();
		solution = list.words.GetValue(randomNumber).ToString();
		solutionChild.characterLimit = solution.Length;
		mixedWord = mixWord(solution);
	}
\end{lstlisting}
Diese Funktion erzeugt eine zufällige Zahl mit der \textit{GetRandomNumbers} Funktion, danach wird mit dieser aus der Liste an der Stelle der zufälligen Zahl ein Wort geholt. Dieses wird in die Variable für die Lösung gespeichert. Damit das Kind keinen zu langen Text in das Textfeld schreiben kann, wurde die Länge für das Eingabefeld, die Länge die eingegeben werden kann auf die Länge des Wortes gesetzt. Als Letztes wird die Funktion \textit{mixWord(solution)} aufgerufen, diese gibt dem Skript ein Wort zurück, das gemischt ist. Als Übergabe in diese Funktion wird das aus der Liste geholte Wort übergeben.\\
\begin{lstlisting}[language=csh, caption={WordMix.cs mixWord-Funktion}]
	public string mixWord(string word){
		string finishedMixing = "";
		System.Random rnd = new System.Random();
		SortedList<int,char> list = new SortedList<int,char>();
		foreach(char c in word)
			list.Add(rnd.Next(), c);
		foreach(var x in list){
			finishedMixing += x.Value.ToString();
		}
		if(word.Equals(finishedMixing)){
			mixWord(word);
		}
		return finishedMixing;
	}
\end{lstlisting}
Diese Funktion erzeugt eine temporäre Variable \textit{finishedMixing} diese ist mit einem leeren String gefüllt. Danach wird eine zufällige Zahl erzeugt. Dafür wird nicht die Methode von Unity verwendet, sondern die in C# verwendet werden kann. Dafür wird ein Objekt der Klasse \textit{System.Random} erzeugt. Danach wird eine sortierte Liste erzeugt. In diese wird das Wort gespeichert. Um das Wort zufällig in die Liste zu bekommen, wird eine \textit{foreach}-Schleife genutzt. Diese fügt an eine zufällige Zahl einen Buchstaben aus dem Wort ein. Der Aufruf \textit{rnd.Next()} gibt eine zufällige Zahl aus, die in der Reichweite eines Integers ist. Das heißt es können sehr kleine aber auch sehr große Zahlen rauskommen. Danach muss mit einer weiteren \textit{foreach}-Schleife das Wort zu einem String zusammengefügt werden. Dafür wird an jeder Stelle der Liste das Zeichen an den leeren String gehangen. Da diese Methode nicht garantiert, dass das Wort nicht zufällig gleich zusammengesetzt wird, wird in einem \textit{If}-Statement abgefragt, ob das neue Wort das gleiche wie das Wort ist, was in die Funktion übergeben wird. Wenn das Wort dasselbe ist, wird die Funktion mit dem gleichen Wort noch einmal aufgerufen. Wenn das Wort unterschiedlich ist, wird dieses zurückgegeben.\\
\begin{lstlisting}[language=csh, caption={WordMix.cs GetRandomNumbers-Funktion}]
	public int GetRandomNumbers(){
		if (list.words.Length != 0) {
			return UnityEngine.Random.Range(0, list.words.Length);
		}
		else{
			return -1;
		}
	}
\end{lstlisting}
Hier wird eine zufällige Zahl erzeugt, die Liste startet an Index null und endet mit der Zahl der Länge der Liste. Also wird erst abgefragt, ob die Liste leer ist, wenn das der Fall ist, wird minus eins zurückgegeben. Wenn in der Liste aber mindestens ein Wort steht, wird mit dem Zufallszahlgenerator von Unity eine Zufallszahl zwischen null und der maximalen Länge der Liste erzeugt. Diese Funktion muss nicht angepasst werden, wenn die Liste wächst. So können immer mehr Wörter hinzugefügt werden.\\
Die Funktion, die beim Drücken des Testbuttons aufgerufen wird, deaktiviert den Button und ruft die \textit{Coroutine}, die das Ergebnis überprüft und verarbeitet.\\
\begin{lstlisting}[language=csh, caption={WordMix.cs waiter-Funktion}]
	IEnumerator waiter(int sec){
		solutionChild.interactable = false;
		if(lvlCount <= lvlAmount){
			if(solution.Equals(solutionChild.text)){
				//change color green
				imageColor.color = new Color32(37, 250, 53, 255);
				yield return new WaitForSeconds(sec);
				solutionChild.text = "";
				PlayGame();
			}
			else{
				//change color red
				imageColor.color = new Color32(251, 37, 37, 255);
				yield return new WaitForSeconds(sec);
				//change color to white
				imageColor.color = new Color32(255, 255, 255, 255);
				solutionChild.text = "";
				wrongChoices++;
			}
		}
	}
}
\end{lstlisting}
Zuerst wird das Eingabefeld deaktiviert. Danach wird, wie sonst auch, zuerst überprüft, ob noch Level gespielt werden sollen. Danach wird, wenn das eingegebene Wort richtig ist, der Rahmen grün und nach einer Sekunde wird das nächste Wort geladen. Dafür muss das Feld geleert werden und die Funktion \textit{PlayGame} aufgerufen werden. Wenn das Kind falsch liegt, wird der Rahmen rot und nach einer Sekunde wieder weiß. Das Textfeld wird geleert und der Zähler für die Fehler wird nach oben gezählt.
\subsection{Szene - Nach Abschluss des Levels}
\subsubsection{Nach Abschluss des Levels - Design}
\graphic{finishScreen}{End Szene nach Abschluss eines Levels}
Diese Szene wird geladen, wenn das Kind ein Level beendet. Die Szene bekommt dort wo, die die Überschrift \textit{Header} steht, eine Botschaft vom Skript übergeben. Je nachdem wie viele Fehler das Kind hat, wird dort wo \textit{Glückwunschtext} steht eine andere Nachricht ausgegeben. Dort wo die drei weißen Vierecke sind, werden aus einem Prefab ein Stern erzeugt. Diese kann das Kind sammeln und im Hauptmenü angezeigt bekommen. Ganz unten befindet sich ein Knopf, der in das Hauptmenü zurückführt. Somit kann das Kind dann ein neues Level auswählen. In der Abbildung 5.38 ist die Szene zu sehen, wenn das Kind keine Fehler gemacht hat.
\graphic{finishScreen0Mistakes}{End Szene mit Null fehlern}
Es werden keine Sterne erzeugt, wenn der Schüler/die Schülerinnen mehr als vier Fehler gemacht hat. Bei genau vier oder weniger Fehlern wird der Stern auf der ganz linken Seite erzeugt. Wenn der Nutzer genau zwei oder weniger Fehler hat, wird der Stern auf der rechten Seite erzeugt. Der Stern in der Mitte wird nur bei genau null Fehlern erzeugt.
\subsubsection{Nach Abschluss des Levels - Skript}
\begin{lstlisting}[language=csh, caption={FinishScreen.cs Variablen Deklaration}]
public class FinishScreen : MonoBehaviour
{
	public Text TextfieldMistakes;
	public Text head;
	private GameObject spawnedStarLeft;
	private GameObject spawnedStarCenter;
	private GameObject spawnedStarRight;
	public GameObject LeftStarSpawn;
	public GameObject CenterStarSpawn;
	public GameObject RightStarSpawn;
	public GameObject star;
	private int mistakes;

	public Button menu;
\end{lstlisting}
Das letzte Skript benötigt zwei Textfeld Objekte für die Überschrift und den Text, der je nach Fehler unterschiedlich ist. Um die Sterne zu erzeugen, werden drei \textit{GameObjects} benötigt. In diese werden die Sterne \textit{Instantiated}. Es werden drei leere Bereiche benötigt, um den einzelnen Sternen eine Position zuzuweisen. Damit auch ein Stern erscheint, wird ein \textit{GameObjekt} mit dem Prefab des Sternes benötigt. Zuletzt braucht es eine Variable für die Fehler und ein Objekt für den Menübutton.\\
\begin{lstlisting}[language=csh, caption={FinishScreen.cs Start-Funktion}]
	void Start()
	{
		menu.onClick.AddListener(() => GoMenu());
		mistakes = PlayerPrefs.GetInt("wrongAnswers");
		SpawnStars();
	}
\end{lstlisting}
Die \textit{Start} Funktion fügt dem Menü Button einen Listener zu. Danach holt es sich aus der Datei die Variable, die die Fehler gespeichert hat, die Anzahl. Als Letztes wird eine Funktion aufgerufen, die die Sterne erzeugen soll.\\
Die Funktion für das Menü ist schnell erklärt und wird nicht gezeigt, diese setzt alle statischen Variablen auf 0 zurück und lädt die Menüszene mit dem \textit{SzeneManager}\\
\begin{lstlisting}[language=csh, caption={SpawnStars.cs Start-Funktion}]
	public void SpawnStars(){
		head.text = ("Schade!");
		TextfieldMistakes.text = ("Nächstes Mal klappt's!");
		if(mistakes <= 4){
			SaveDataManager.RiddleSaveData.stars++;
			spawnedStarLeft = Instantiate(star, LeftStarSpawn.transform.position, Quaternion.identity);
			spawnedStarLeft.transform.SetParent(LeftStarSpawn.transform);
			head.text = ("Glückwunsch!");
			TextfieldMistakes.text = ("Nur " + mistakes + " Fehler!");
			if(mistakes <= 2){
				SaveDataManager.RiddleSaveData.stars++;
				spawnedStarCenter = Instantiate(star, CenterStarSpawn.transform.position, Quaternion.identity);
				spawnedStarCenter.transform.SetParent(CenterStarSpawn.transform);
				head.text = ("Glückwunsch!");
				TextfieldMistakes.text = ("Nur " + mistakes + " Fehler!");
				if(mistakes == 0){
					SaveDataManager.RiddleSaveData.stars++;
					spawnedStarRight = Instantiate(star, RightStarSpawn.transform.position, Quaternion.identity);
					spawnedStarRight.transform.SetParent(RightStarSpawn.transform);
					head.text = ("Glückwunsch!");
					TextfieldMistakes.text = ("Super, alles richtig!!!");
				}
			}
		}
		SaveDataManager.SaveGame();
	}
\end{lstlisting}
Diese Funktion besteht aus verknüpften \textit{If}-Statements, als Erstes wird davon ausgegangen, dass das Kind zu viele Fehler für Sterne gemacht hat. Deshalb wird die Überschrift auf \textit{Schade!} gesetzt. Die Botschaft darunter wird auf einen motivierenden Satz gesetzt. In dem Fall das zu viele Fehler gemacht wurden, wäre dieser \textit{Nächstes Mal klappts's}. Wenn das Kind unter vier Fehlern gemacht hat, wird die Zahl der gespeicherten Sterne um eins erhöht, dafür wird die Variable aus dem Skript um die Rätsel Ergebnisse zu speichern aufgerufen, und die dort angelegte Variable für die Anzahl der Sterne um eins erhöht. Danach wird der erste Stern erzeugt, die Texte der Überschrift werden ab dem ersten Stern immer \textit{Glückwunsch!} anzeigen und für der Text für die Fehler wird außer bei null Fehlern den Text \textit{Nur ... Fehler!} anzeigen. Wenn das Kind dann unter zwei Fehlern gemacht hat, wird der zweite Stern erzeugt und die Variable erneut erhöht. Als letzte Abfrage wird, überprüft, ob das Kind keine Fehler gemacht hat. In diesem Fall wird ein dritter Stern erzeugt und die Sternerzähler Variable um eins erhöht. Der Text unter der Überschrift der Szene zeigt nun an \textit{Super, alles richtig!!!}. Nachdem diese Abfragen durchgelaufen sind, muss noch die Funktion aus dem Skript aufgerufen werden, die die Daten speichert. Dies ist mit dem folgenden Befehl zu erreichen, \textit{SaveDataManger.SaveGame()}.\\