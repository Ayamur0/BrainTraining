% \graphic{riddleScene}{Szenenaufbau für Rätsel}
% Text für das Design der Lernspiel szenen von der ersten bis zur letzten.
% Liste mit allen Szenen machen, von den Grundrechenarten bis zum endscreen
\subsection{Szene - Menü}

%TODO Variablen in den Skripten Checken
\subsubsection{Menü - Design}
\graphic{menuLearning}{Auswahl der Level}

In der Abbildung 5.15 ist die Auswahl der sechs unterschiedlichen level zu sehen. Die Szene besteht aus einem zurück Button und sechs weiteren für die Lernspiele. Mit dem zurück Button kommt man wieder in das Hauptmenü. Die restlichen Buttons leiten den Nutzer ein Menü weiter. In dem nächsten Menü werden die Alternativen und die Schwierigkeiten des Spiels festgelegt. Die Buttons wurden im Programm Inkscape vector graphics erstellt. Damit die Beiden Teile des Projektes zusammenpassen wurde ein Einheitliches Design überlegt. Diese unterscheidet sich in den Farben und in den Buttons. In dieser Szene wurden für jeden Button ein PNG entworfen. Wie dies im Programm Inkscape aussieht, ist in der Abbildung 5.16 zu sehen. In diesem Programm wurden die Buttons für die Szenen entworfen.\\
\graphic{InkscapeButtonGreen}{Button Design} 
Der Button besteht aus mehrern Objekten, diese sind in der Abbildung 5.17 zu sehen. Für den Hintergrund des Buttons wurden drei Rechtecke erzeugt, ein Weißes, ein Dunkelgüßnes und ein Hellgrünes. Diese werden immer Kleiner und übereinander gelegt. Von allen Rechteecken werden die Kanten abgerundet. Als letztes kommen noch zwei Textfelder, jedes der Textfelder ist unterschiedlich gestalltet, so das am Ende die gewünschte Schrifft rauskommt. 
\graphic{InkscapeButtonSingleTiles}{Button einzelteile}
Nachdem die Designs für die Buttons fertiggestellt wurden, werden diese auf den einzelnen Unity Button gezogen und ändert somit sein Design. Dies ist in der Abbildung 5.18 zu sehen.
In dieser Abbildung, markiert ein grüner Pfeil die stelle in die das Image des Buttons ausgewählt wird.
\grapic{buttonImgChange}{Button Image ändern}

\subsubsection{Menü - Skript}

In diesem Abschnitt wird das Skript erklärt, welches die Auswahl der Level verwaltet.
Das Skript wird hierfür in kleine Teile zerlegt und diese werden dann einzelnd erklärt.\\

\begin{lstlisting}[language=csh, caption={MenuPickLevel.cs Klasse Menü Imports}]
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using System;
\end{lstlisting}

Ganz oben im Skript werden verschiedene Bibliotheken eingebunden. Diese werden für die Skripte in den Nachfolgenden Abschnitten sehr ähnlich sein oder sich gar nicht unterscheiden. Mithilfe des Befehls using werden Bibliotheken von C# und Unity importiert. Diese werden benötigt, um zum Beispiel Arrays zu erstellen und verwalten zu können. Mit den Bibliotheken von Unity, kann man auf die Objekte in Unity per Skript zugreifen und diese verwalten oder bearbeiten.\\

\begin{lstlisting}[language=csh, caption={MenuPickLevel.cs Klasse Menü Variablen}]
public class MenuPickLevel : MonoBehaviour
{
	public Button[] buttonsMenu = new Button[7];

	public enum LvlType{
		BACK = 1,
		QUANTITIES = 2,
		MATHOPERATIONS = 3,
		TRIANGLE = 4,
		LIGHTNIGVIEW = 5,
		PATTER = 6,
		MIXEDWORDS = 7
	}

	public static int loadButtonsPrefab = 0;
\end{lstlisting}

Nachdem alle notwenigen Bibliotheken eingebunden wurden, wird die Klasse deklariert. Die Klasse bekommt hinten MonoBehaviour angehängt, dies ermöglicht uns unteranderem Funktionen wie void start() und void() update zu nutzen. Wenn ein Skript diese Funktionen nicht benötigt, weil es zum Beispiel nur etwas ausrechen muss, so kann das MonoBehaviour dahinter weggelassen werden.\\
In den darauf Folgenden Zeilen werden die Variablen deklariert die für das Skript notwendig sind. Zu erst werden die Buttons deklariert. Der auskommentierte Code stellt eine alternative Lösung dar. In Unity können Buttons in das Skript eingefügt werden, dies kann man in der Abbildung 5.16 sehen. Dadruch können wir im Code dann auf das Objekt des jeweiligen Buttons zugreifen und mit diesen arbeiten. Es gibt zwei möglichkeiten mehrere Buttons zu implementieren. Entweder man deklariert die anzahl an Buttons selbst oder man nutzt ein Array dafür. Beides ist in den folgenden Abbildungen zu sehen.
\graphic{buttonZuweisen}{Buttons in Unity einzeln zuweisen}
\graphic{buttonsIntoArray}{Buttons in Unity in Array einfügen}
In c# gibt es standartmäßig nicht die möglchkeit ein Const array zu erstellen. Für jeden Button wird in diesem Skript eine Konstante benötigt, den diese soll dem nachfolgenden Skript weiterleitet welcher Button genau gedrückt wurde. Dies ist wichtig, da die Level unterschiedliche Varianten und Schwierikeitsgrade beinhalten und dementsprechend unterschiedliche Buttons auftauchen sollen. Um ein Array zu deklarieren was ähnlich zu einer Konstanten Variablen funktioniert, kann man ein array das readonly ist verwenden oder man nutz eine Enumeration. Eine Enumeration ist eine Reihe bennanter Konstanten, das heißt, alle Konstanten die von Hand einzeln erzeugt wurden, können in die Enumeration eingespeichert werden. Da diese Lösung weniger Code benötigt und für mehrer Buttons effektiver ist, wurde diese Möglichkeit auch umgesetzt. In der Menü Szene sind beide Möglichkeiten im Code geschrieben, aber die Umsetzung alle Buttons und Konstanten einzeln zu deklarieren wurde auskommentiert.\\
Als letztes wird eine static variable deklariert, diese bekommt später den wert einer Konstanten zugewiesen. In der nächsten Szene kann dann auf diese zugegriffen werden und somit ist dem nachfolgenden Skript bewusst welche Buttons für die Nächstes Szene geladen werden müssen. In Unity gibt es unterschiedliche möglichkeiten um Werte zwischen Skripten transferieren zu können. Einmal wären das static Variablen. Unity selbst biete aber auch die Möglchkeit einen Wert in eine Varibale in einem File zu speichern, dafür wird der PlayerPrefs.setInt/String/Float("variablen name", variablen wert); verwendet. Diese Variante wird in diesem Skript nicht verwendet, da nur die Information aus dem alten Skript benötigt wird und diese nur für diese beiden Skripte notwendig ist. Wenn die Information für mehrer Skripte notwendig wäre, könnte man diese durch den PlayerPrefs befehl speichern.\\

\begin{lstlisting}[language=csh, caption={MenuPickLevel.cs Klasse Menü start Funktion}]
	void Start()
	{
		Debug.Log(buttonsMenu.Length);
		for (int i = 0; i < buttonsMenu.Length; i++){
			int temp = i;
			buttonsMenu[temp].onClick.AddListener(() => loadAdvancedOptions((LvlType)temp + 1));
		}
	}
\end{lstlisting}
In der Start werden jedem Button ein Listener hinzugefügt, es gibt auch hier wieder die möglichkeit dies für jeden Button einzeln zu erledigen oder mithilfe eines Arrays und der Enumeration dies in einer For-Schleife durchzuführen.\\
Die Schleife startet bei 0 und läuft bis sie durch alle Buttons durch iteriert hat. Dabei kann es zu einem Problem kommen, das die Variable i gefanngen nimmt. Das bedeutet, egal welcher Button gedrückt wird es lädt die letzt Möglichkeit der Iteration, also würde das für uns so aussehen, das jeder Button in dem gleichen Level endet. Um diese Problem zu verhindern, wird eine Temporäre Variabel temp deklariert, die den Wert von i zugewiesen bekommt. Jetzt wird jedem Button aus dem Array an der Position temp ein onClick event hinzugefügt, welches die Möglichkeit biete, wenn der Button gedrückt wurde etwas oder eine Funktion auszuführen. In diesem fall wird die AddLister Funktion aufgerufen. Mit den leeren Klammern und dem Pfeil (() =>) wird eine Funktion deklariert die ausgeführt wird wenn der Button gedrückt wurde. In diesem Fall wird die Funktion die uns die Szene mit den jeweiligen Varianzen an Modi und Schwierigkeiten lädt. Hierbei wird der Integer Wert aus temp verwendet, dieser muss in den Enumerations Typen umgewandelt werden, diese umwandlung wird Casten genannte. Dabei wird vor die Variable der gewünschte Typ in Klammern geschrieben (LvlTyp). Danach wird die Variable Temp + 1 verwendet, das hat den Grund, dass später mit dieser Variablen gearbeitet wird und das Skript für das erweiterte Menü diese Variable ab der Stelle eins bearbeitet. In einer früheren Version, gab es in dieser Szene einen Menü Button der die Stelle 0 belegt hat und später entfernt wurde. Die Skripte funktionieren aber ohne diesen Button ohne Probleme, deshalb wurde es nicht angepasst.\\

\begin{lstlisting}[language=csh, caption={MenuPickLevel.cs Klasse Menü loadAdvancedOptions Funktion}]
	public void loadAdvancedOptions(LvlType choice){
		switch (choice)
		{
			case LvlType.BACK:
				loadButtonsPrefab = (int)LvlType.BACK;
				SceneManager.LoadScene("MainMenu");
				break;
			case LvlType.QUANTITIES:
				loadButtonsPrefab = (int)LvlType.QUANTITIES;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.MATHOPERATIONS:
				loadButtonsPrefab = (int)LvlType.MATHOPERATIONS;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.TRIANGLE:
				loadButtonsPrefab = (int)LvlType.TRIANGLE;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.LIGHTNIGVIEW:
				loadButtonsPrefab = (int)LvlType.LIGHTNIGVIEW;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.PATTER:
				loadButtonsPrefab = (int)LvlType.PATTER;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;
			case LvlType.MIXEDWORDS:
				loadButtonsPrefab = (int)LvlType.MIXEDWORDS;
				SceneManager.LoadScene("MenuLearingAdvancedOptions");
				break;

			default:
				break;
		}
	}
\end{lstlisting}

In Zeile 46 beginnt die Funktion die die nächste Szene lädt. Die szene unterscheidet mit einem switch-case statement, welcher Button gedrückt wurde und speichert den passenden wert in die static Variable ein. Der Wert aus der Enumeration wird hierbei in einen Integer Wert umgewandelt. Danach wird die nächste Szene geladen. Der Zurück Button leitet den Nutzer zum Hauptmenü zurück und die anderen Buttons laden die neue Szene, diese wäre das erweiterte Menü. Das erwiterte Menü ist die gleiche Szene für alle Buttons, da diese sich nur in der Anzahl an Auswahlmöglichkeiten unterscheidet. Dies wird aber im nächsten Abschnitt genauer erläutert.\\
In dieser Szene ist aber noch anzumerken, das es einen Fehler gabe bei den Konstanten, so dass im Erweiterten Menü zweimal das Selbe Level geladen wurde, wie dieser genau zu stande kam und wie er gelöst wurde wird aber im nächsten Abschnitt genauer erläutert.

\subsection{Szene - Erweitertes Menü}
\subsubsection{Erweitertes Menü - Design}
In diesem Abschnitt, wird das Design des erwitertetn Menüs erklärt. In diesem Menü gibt es wieder einen zurück Button, der in das vorherige Menü zurück leitet. Auf der Linken seite des Menüs werden die Alternativen Spielmodi angezeigt und auf der rechten Seite die Schwierigkeiten. Zu sehen ist dies in der Abbildung 5.20. Die Alternativen sind nicht für jedes Level vorhanden oder gleich, wenn es keine zur auswahl gibt, ist die Linke hälfte einfach Leer. Für die Beiden Seiten wurden auch wieder mehrere Buttons Designs angefertigt.
\graphic{basicOperatorsAdvanced}{Auswahl der einzelnen Optionen eines Levels}
Um das Ausgewählte Spiel starten zu können müssen auf beiden Seiten eine Option gewählt werden. solange nicht auf beiden seiten ein Button ausgewählt wurde ist der Start Button deaktiviert. Wenn ein Button auf einer seite Ausgewählt wurde wird dieser Deaktiviert und kann nicht wiederholt ausgewählt werden, sobald eine andere Alternative ausgewält wird, wird diese Deaktiviert und die andere wieder aktiviert. So wird verhindert, das nie mehr als eine Möglichkeit aktiviert sein kann. Wenn ein Level ohne Alternative ausgewählt wurde, muss nur eine Schwierigkeit ausgewählt werden um das Spiel zu starten. In der Abbildung 5.21 ist eine Auswahl zu sehen, der Start Button ist hier noch Deaktiviert, weil keine Schwierigkeit gewält wurde. 
\graphic{basicOperatorsAdvancedSingleChoice}{Einzelne Auswahl}
Nachdem auf jeder Seite ein Button gewählt wurde, ist der Start Button nicht mehr Deaktiviert und der Spieler kann das Spiel starten.
\graphic{basicOperatorsAdvancedFinish}{Auswahlbedingung um das Level zu laden}
\subsubsection{Erweitertes Menü - Skript}
In diesem Abschnitt, wir das Skript erklärt, da die Imports die Selben sind, werden diese nicht erneut erklärt.
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs Variable Deklaration}]
public class MenuPickLevelAdvanced : MonoBehaviour
{

	//Buttons
	public Button back;
	public Button start;

	public List <Button> leftSideList = new List<Button>();
	private List<Button> rightSideList = new List<Button>();

	public GameObject buttonPref;
	public GameObject spawnerLeft;
	public GameObject spawnerRight;
	private GameObject spawnedObject;

	public Sprite[] quantitiesModes = new Sprite[2];
	public Sprite[] mathModes = new Sprite[4];
	public Sprite[] difficulty = new Sprite[3];

	public static int maxNumberStatic = 0;
	public static int lvlAmmountStatic = 0;
	public static int fourChoices = 0;
	public static int wallSize = 0;

	private int loadButtonsNumber = 0;
	private bool leftSide = false;
	private bool rightSide = false;
	private Vector3 scaleSize = new Vector3 (1.0f, 1.0f, 1.0f);
\end{lstlisting}
%TODO Variablen in den Skripten Checken
Die Klasse beinhaltet mehr Variablen und Objekte, in diesem Fall wurde Zwei Buttons deklariert da diese in der Szene immer vorkommen. Die Buttons für die Linke und rechte Seite werden in Listen gespeichert, also nicht in Unity festgelegt. Um mehrere Buttons per Skript zu spawnen, werden nach den Listen Objekte mit einem Prefab eines Buttons und den beiden Bereichen hier spawnerLeft und spawnerRight deklariert. Diese drei sind Public, da sie in Unity den Objekten zugewiesen werden. Das Objekte spawnedObject, wird hier deklariert und kann private bleiben, da wir es nur im Skript verwenden. Der gebrauch wird in den Unteren Funktionen erklärt.\\
Da die Buttons für die Alternativen und die Schwierigkeit unterschiedlich aussehen, werden zunächst drei Sprite Arrays erzeugt, in diese Werden die Bilder der vorgefertigten Buttons gezogen. So können wir auf die Bilder in der richtigen Reihnfolge später zugreifen und diese verwenden.\\
Als nächstes, benötigen wir wieder static Variablen, diese speichern die Werte mit denen das Level Initalisiert wird. Die maxNumberStatic speichert die Zahl ein die Maximal später random generiert werden kann. Je nach Schwierigkeit ist diese Größer oder kleiner. Die lvlAmmountStatic legt fest, wie viele Level das Kind spielen muss bevor er es abgeschlossen hat. Die fourChoices Variable speicher die Linke auswahl ein. Der Name ist ein wenig Irreführend, da es nur einspeichern soll welcher Button Links ausgewählt wurde. Das sind die möglichkeiten im Spiel größer,kleiner, gleich oder bei den Grundrechenarten. Also Speichert diese die Zahlen von eins bis 4 ein. Die wallSize ist nur für die Rechenmauer notwendig, je nach der Schwierigkeit, ist die mauer unten drei, vier oder fünf steine groß.\\
Als letztes werden noch vier private Variablen benötigt. Die Variable loadButtonsNumber wird die static Variable aus der Vorherigen Szene bekommen. Die beiden Boolean Variablen werden benötigt, um die Linke und Rechte seite der Buttons zu überprüfen. Da die Buttons wenn sie in einem Canvas erzeugt werden kleinerskaliert werden, müssen diese mithilfe des Vektors wieder auf die Originalgröße Skaliert werden.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs Start Funktion}]
	void Start()
	{
		loadButtonsNumber = MenuPickLevel.loadButtonsPrefab;
		back.onClick.AddListener(() => GoBack());
		start.onClick.AddListener(() => LoadGame());
		SpawnButtonsRight();
		if(loadButtonsNumber == 2 || loadButtonsNumber == 3){
			SpawnButtonsLeft();
		}
		else{
			leftSide = true;
		}
	}
\end{lstlisting}
Die start Funktion wird sobald die Szene geladen wird aufgerufen, diese speichert einmal den Wert der static Variablen aus dem vorherigen Skript in eine Variable, da die Variable Public war kann mit dem Namen des Skriptes und dem namen der Variablen auf diese zugegriffen werden.
Danach bekommen die Buttons um zurück zu gehen und um das level zu starten ihre Funktion zugewiesen. Da die Buttons auf der Rechtenseite immer gleich sind, werden diese als nächstes erzeugt, dies wird in der Funktion SpawnButtonsRight erledigt. Danach muss für die Linke seite überprüft werden, ob es überhaupt alternativen gibt, wenn dies nicht der Fall wäre würde der Boolean für die Linke seite auf true gesetzt werden. Um zu überprüfen welche Alterantiven wir benötigen wird die loadButtonsNumber überprüft. Wenn diese den Wert 2 oder 3 zugewiesen bekam, haben wir entweder das Spiel größer, kleiner, gleich oder die Grundrechenarten. Wenn eine dieser beiden Möglichkeiten besteht, werden die Buttons auf der Linken seite erzeugt.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs Update Funktion}]
	void Update(){
		if(!leftSide || !rightSide){
			start.interactable = false;
		}
		if(leftSide && rightSide){
			start.interactable = true;
		}
	}
\end{lstlisting}
Die Update Funktion von Unity wird jeden Frame aufgerufen und überprüft nur ob die Booleans für die Linke und Rechte seite true sind oder ob noch eine Seite nicht ausgewählt wurde. Wenn auf beiden Seiten etwas ausgewählt wurde, kann das Spiel gestartet werden, wenn eine der beiden Variablen false ist, ist der start Button deaktiviert. Um einen Button zu aktivieren oder zu deaktivieren wird die Variable interactable des Buttons auf false oder true gesetzt. Je nachdem ist der Button im Spiel dann ausgegraut oder eben nicht.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs GoBack Funktion}]
	public void GoBack(){
		MenuPickLevel.loadButtonsPrefab = 0;
		SceneManager.LoadScene("MenuLearning");
	}
\end{lstlisting}
Die GoBack funktion wird aufgerufen wenn der zurück Button gedrückt wurde. in dieser wird die Static Variabel aus dem Vorherigen Skript wieder auf 0 gesetzt, damit es zu keinen Fehler in der Levelauswahl kommt, da diese sonst den vorherigen Wert weiterhin besitzen würde. Danach wird mithilfe des aufrufes SceneManager.LoadScene("MenuLearning") die Menü Auswahl szene aufgerufen.
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs LoadGame Funktion}]
	public void LoadGame(){
		switch (loadButtonsNumber)
		{
			case 2:
				SceneManager.LoadScene("CompareQuantities");
				break;
			case 3:
				SceneManager.LoadScene("basicOperations");
				break;
			case 4:
				SceneManager.LoadScene("triangle");
				break;
			case 5:
				SceneManager.LoadScene("lightningView");
				break;
			case 6:
				SceneManager.LoadScene("finishPattern");
				break;
			case 7:
				SceneManager.LoadScene("MixedWords");
				break;
			default:
				break;
		}
	}
\end{lstlisting}
Die Funktion LoadGame kontrolliert mithilfe eines switch-case-Statements, welcher Button in der Szene davor gedrückt wurde und dann die Passende Szene.\\
Das Problem was nach der Verbesserung des ersten Skripts aufgetreten ist, war das die Szene mit den Grundrechenarten die Zahl 4 zugewiesen bekommen sollte, diese war aber der dritte Fall im switch-case-statement und somit wurde in dieser Szene immer die Rechenmauer geladen. Die Zahlen wurden dann im Skript davor angepasst und die Grundrechenarten bekamen die nummer drei. Was in der Funktion SpawnButtonsLeft zu Problemen führte.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs SafeOptionsRight Funktion}]
	public void SafeOptionsRight(int whichButton){
		for (int i = 0; i < rightSideList.Count; i++){
			if(i != whichButton){
				rightSideList[i].interactable = true;
				continue;
			}
			rightSide = true;
			rightSideList[i].interactable = false;
		}
		switch (whichButton)
		{
			case 0:
				lvlAmmountStatic = 10;
				maxNumberStatic = 10;
				wallSize = 3;
				break;
			case 1:
				lvlAmmountStatic = 15;
				maxNumberStatic = 15;
				wallSize = 4;
				break;
			case 2:
				lvlAmmountStatic = 20;
				maxNumberStatic = 20;
				wallSize = 5;
				break;
			default:
				break;
		}
	}
\end{lstlisting}
In dieser Funktion wird die Auswahl der Schwierigkeit des Levels gespeichert. Diese bekommt eine zahl zwischen null und zwei zugewiesen. In einer for-schleife wird dann überprüft welcher Button gedrückt wurde. Wenn ein Button der ungleich i gedrückt wurde, wird dieser aktiviert und die Schleife springt einen durchgant weiter. Wenn i die gleiche Zahl wie die Variable whichButton ist, wird der Boolean auf true gesetzt und der aktuell gedrückte Button wird deaktiviert.\\
Nachdem die Schleife durch gelaufen ist, wird mithilfe eines switch-case-statements überprüfut welcher der drei Buttons ausgewählt wurde und je nachdem eine Level anzahl, eine maximale Random Nummer und die Mauer größe gespeichert.\\
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs SafeOptionsLeft Funktion}]
	public void SafeOptionsLeft(int whichButton){
		for (int i = 0; i < leftSideList.Count; i++){
			if(i != whichButton){
				leftSideList[i].interactable = true;
				continue;
			}
			leftSide = true;
			leftSideList[i].interactable = false;
		}
		if(loadButtonsNumber == 2){
			setQuantitiesOptions(whichButton);
		}
		else if(loadButtonsNumber == 3){
			setMathOptions(whichButton);
		}

	}
\end{lstlisting}
Die Funktion SafeOptionsLeft soll speichern welche der Alternativen links gespeichert wurde. Also wird einmal wie in der Funktion SafeOptionsRight mithilfe einer For-Schleife kontrolliert welcher Button gedrückt wurde und dieser wird dann Deaktiviert. Die Boolean Variable für Links wird dann auch auf True gesetzt. Da es in zwei Leveln Alternativen gibt, wird überprüft welches Level gewählt wurde. Im Falle der Zahl zwei wird die Funktion aufgerufen die Speichern soll ob die Kinder Objekte oder Zahlen vergleichen sollen. Im Falle der drei wird die Funktion aufgerufen die Speicher welche der vier Grundrechenarten das Kind spielen möchte. 
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs setQuantitiesOptions Funktion}]
	public void setQuantitiesOptions(int whichButton){
		switch (whichButton)
		{
			case 0:
				fourChoices = 1;
				break;
			case 1:
				fourChoices = 2;
				break;
			default:
				break;
		}
	}
\end{lstlisting}
Diese Funktion überprüft mithilfe eines switch-case-statements welcher der Beiden Varianten ausgewählt wurde und speichert diese in die Variable fourChoices. Durch diese weiß das Spiel größer, kleiner, gleich ob sie Zahlen oder Objekte anzeigen soll.
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs setMathOptions Funktion}]
	public void setMathOptions(int whichButton){
		switch (whichButton)
		{
			case 0:
				fourChoices = 1;
				break;
			case 1:
				fourChoices = 2;
				break;
			case 2:
				fourChoices = 3;
				break;
			case 3:
				fourChoices = 4;
				break;
			default:
				break;
		}
	}
\end{lstlisting}
Dieses Skript arbeiten gleich wie das Skript davor, es überprüft welche der vier Grundrechenarten ausgewählt werden sollten und speicher diese ab, damit das Skript der Grundrechenarten weiß ob das Kind addieren, subtrahieren, multiplizieren oder dividieren möchte.
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs SpawnButtonsLeft Funktion}]
	public void SpawnButtonsLeft(){
		int size = 0;
		if(loadButtonsNumber == 3) size = 4;
		else size = 2;
		for (int i = 0; i < size; i++){
			int copy = i;
			spawnedObject = Instantiate(buttonPref, spawnerLeft.transform.position, Quaternion.identity);
			spawnedObject.name += i;
			spawnedObject.transform.SetParent(spawnerLeft.transform);
			spawnedObject.transform.localScale = scaleSize;
			spawnedObject.GetComponent<Image>().preserveAspect = true;
			leftSideList.Add(spawnedObject.GetComponent<Button>());
			leftSideList[i].onClick.AddListener(() => SafeOptionsLeft(copy));
			if(size == 2){
				leftSideList[i].GetComponentInChildren<Image>().sprite = quantitiesModes[i];
				// leftSideList[i].GetComponentInChildren<Image>().preserveAspect = true;
				continue;
			}
			else if(size == 4){
				leftSideList[i].GetComponentInChildren<Image>().sprite = mathModes[i];
			}
		}
	}
\end{lstlisting}
In diesem Skript kam es zu einem Problem, nachdem das erste Menü Skript angepasst wurde. Dieses Skript läuft mit einer For-Schleife durch und erzeugt je nachdem welche Zahl in der Variablen loadButtonsNumber steht die richtige anzahl an Buttons. Für das Spiel größer, kleiner, gleich erzeugt es zwei Buttons und für die Grundrechenarten vier. Da aber die Grundrechenarten die Nummer drei bekamen wurde ein Button zu wenig erzeugt. Um dies zu verhindern, wird am anfang einmal überprüft ob die loadButtonsNumber zu diesem Zeitpunkt eine drei beinhaltet und wenn ja wird die größe auf 4 gesetzt, wenn das nicht der fall ist wird diese auf zwei gesetzt. Somit werden genung Buttons für die Alternativen erzeugt.\\
Die For-Schleife muss auch hier wieder eine temporäre Variable erzeugen diesesmal wurde sie copy genannt. Um objekte durch ein Skript zu erzeugen wird in das Objekt spawnedObject mithilfe der Instantiate Mehtode, dies ist eine Methode um ein Objekt zu Spawnen der Button erzeugt. Die Instantiate methode bekomme ein GameObjekt das sie spawnen soll in diesem Fall unser Button Prefab, dann benötigit sie eine position, das wäre die Position unseres Spawners auf der Linken seite. Diese bekommen wir durch den aufruf spawnerLeft.transform.position, dieser gibt die Position unser GameObjekts auf der Linken seite zurück und an diese Stelle soll der Button erzeugt werden. Da sie keine Rotation benötigt wird als letzer Übergabewert Quaternion.identity verwendet. Hierbei wird die das Objekt nicht Rotiert.\\
Damit in Unity die Objekte in der Hierarchy unterscheidbar waren, bekamen sie den namen plus i.\\
Um die Buttons richtig anzuordnen wurde ein Overlay mit Verticalen und Horizontalen Layoutgroups angelegt. In der Abbildung 5.23 ist diese zu sehen. Das Objekt Choices bekam eine bekam eine Horizontale Layout Gruppe, die Objekte leftSite und rightSite bekamen eine Vertikale Layout Gruppe. 
%TODO Maybe noch ein Bild
Damit die Buttons in diesen Objekten zu sehen sind, werden dem spawnedObjekt ein Eltern Objekt zugewiesen. Um dies zu erreichen wird spawnedObject.transform.SetParent aufgerufen. Da nach wird das Objekt an der Richtigen stelle angezeigt, aber nicht in der Richtigen größe. Unity Skaliert das Objekt kleiner, da es hierbei dei Größe des Objektes nimmt in dem das neue Objekt erzeugt wird. Damit das Objekt die Originalgröße behält wird für das erzeugte Objekt die Skalierung auf die Originale Größe gestzt. Auch dies ist mithilfe des .transfom.localScale befehls möglich.\\
Bilder in Unity werden unscharf dargestellt. Dies kann verhindert werden wenn die Option preserveAspect auf true gesetzt wird. Auch dies wird für jedes erzeugte Objekt in dieser Funktion erledigt.\\
Nachdem alle Buttons für die Linke seite Erzeugt wurden, werden diese in die liste LeftSideList gespeichert und bekommen danach den Listener zugewiesen. Dieser ruft dann die Funktion auf die Speicher welche Alterantive des Spieles gespeichert werden soll.\\
Nachdem die Buttons Links erzeugt wurden muss die Funktion in einer If und else if abfrage überprüfen welche Bilder den Buttons zugewiesen werden sollen, sonst würde auf den Button gar nichts stehen. Wenn die Variable size die Zahl zwei beinhaltet wird auf den Button Links in den Komponenten Image das passende Bild aus dem Array gespeicher. Der Befehl  leftSideList[i].GetComponentInChildren<Image>().sprite = quantitiesModes[i]; nimmt den Komponenten des Buttons aus der Liste leftSideListe und fügt das Bild aus dem Array an der Stelle i ein.\\
Für die Grunrechenarten wird das selbe angewandt, in dem falle, das die Variable size gleich vier ist.
\graphic{LayoutMenuAdvanced}{Layout Erweitertes Menü}
\begin{lstlisting}[language=csh, caption={MenuPickLevelAdvanced.cs SpawnButtonsRight Funktion}]
	public void SpawnButtonsRight(){
		for (int i = 0; i < 3; i++){
			int copy = i;
			spawnedObject = Instantiate(buttonPref, spawnerRight.transform.position, Quaternion.identity);
			spawnedObject.name += i;
			spawnedObject.transform.SetParent(spawnerRight.transform);
			spawnedObject.transform.localScale = scaleSize;
			spawnedObject.GetComponent<Image>().preserveAspect = true;
			rightSideList.Add(spawnedObject.GetComponent<Button>());
			rightSideList[i].onClick.AddListener(() => SafeOptionsRight(copy));
			rightSideList[i].GetComponentInChildren<Image>().sprite = difficulty[i];
			// rightSideList[i].GetComponentInChildren<Image>().preserveAspect = true;
		}
	}
\end{lstlisting}
Die Funktion SpawnButtonsRight, arbeite gleich wie die SpawnButtonsLeft Funktion, nur das in diesem Fall immer drei Buttons gespawnt werden auf die Richtige größe Skaliert werden und in eine Liste eingefügt werden. Diesen werden danach dann die Bilder der unterschiedlichen Schwierkeitsgrade hinzugefügt.
\subsection{Szene - Grundrechenarten}
\subsubsection{Grundrechenarten - Design}
\graphic{addition}{Grundrechenarten - Addition}
In der Szene der Grundrechenarten gibt es ein Textfeld, dieses wurde mit einem Grünen Pfeil markiert. In diesem steht der Operator, also ob das Kind Addieren, Subtrahieren, Multiplizieren oder Dividieren soll. Die Szene kann mit dem Menü Button oben Links verlassen werden. Die Überschrift der Szene sagt dem Kind, dass es die Zahl ausrechnen soll. Ganz rechts oben steht das aktuelle Level und wie viele es insgesamt gibt. Diese wird, sobald das Kind eine Rechnung richtig hat, um eins hochgezählt. In der Mitte der Szene steht links die erste Zahl, dann der Operator, dann die zweite Zahl. Danach kommt das Gleichheitszeichen und ein Eingabefeld für die Lösung des Nutzers. Dieses Feld wird grün umrandet, wenn die Lösung richtig ist und rot, wenn diese falsch ist. Nach einer falschen Eingabe wird das Eingabefeld wieder geleert. In der Abbildung 5.24 und 5.25 ist der grüne und rote Rand zu sehen. Dieser wird in diesem Fall aus der Szene größer, kleiner, gleich sein, ist aber in den Szenen, in denen er verwendet wird, gleich. 
\graphic{rightChoiceQuantities}{Grüner Rahmen}
\graphic{wrongChoiceQuantites}{Roter Rahmen}
Der Button Testen löst die Funktion aus, die kontrolliert, ob richtig gerechnet wurde. Dieser ist deaktiviert, solange keine Zahl eingeben wurde und wird aktiviert, sobald eine Zahl darin steht.
\subsubsection{Grundrechenarten - Skript}
\begin{lstlisting}[language=csh, caption={MathOperations.cs Variablen Deklaration}]
public class MathOperations : MonoBehaviour
{

	public Text TextNumberLeft;
	public Text TextNumberRight;
	public Text operatorSymbole;
	public Text showLevelNumber;

	public InputField solutionNumber;

	public Button checkButton;
	public Button menu;

	public Image imageColor;

	private int leftNumber;
	private int rightNumber;
	private int solution;
	private int maxRandomNumber = 10;
	private int minRandomNumber = 0;
	private int lvlNumber = 10;
	private int countLvl = 0;
	//add = 1, sub = 2, mult = 3, div = 4
	private int gameMode = 3;
	private int wrongSolution = 0;
\end{lstlisting}
In dem Skript für die Szene, werden zuerst vier Public Textfelder deklariert, diese zeigen verschiedene Informationen an. Einmal, das aktuelle Level und wie viele es insgesamt gibt. Dann zeigt eins der Textfelder den Operator, an den, mit dem das Kind rechnen soll. Die letzten zwei Textfelder zeigen die Zahlen an, die addiert, subtrahiert, multipliziert oder dividiert werden sollten. In dieser Szene benötigt der Schüler/die Schülerin ein Input Feld, in das seine/ihre Lösung geschrieben werden kann. Das Skript bekommt auch zwei Buttons zugewiesen, einen der in das erste Menü zurückführt und einen der das Ergebnis überprüft. Um den Kontrollrahmen zu erzeugen wird ein Objekt vom Typ Image benötigt, dieses liegt hinter dem Input Feld und ist ein wenig größer als das Input Feld selbst. Als letztes benötigt das Skript noch ein Paar variablen um die Zahlen links und rechts zu speichern. Das Skript benötigt eine Variable, die das Ergebnis der Rechnung speichert. Des Weiteren sind zwei Variablen deklariert, um die zufällig generierten Zahlen zu begrenzen. Es gibt eine Variabel die maximale Anzahl an Level festlegt und einen Zähler der nach oben gezählt wird. Es gibt noch zwei letzte Variablen im Skript, die eine legt den Modus fest, also ob addiert, subtrahiert, multipliziert oder dividiert wird. Die andere zählt die Anzahl an Fehler, die das Kind macht.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs Start Funktion}]
	void Start()
	{
		menu.onClick.AddListener(() => GoBack());
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		gameMode = MenuPickLevelAdvanced.fourChoices;
		checkButton.onClick.AddListener(() => buttonClick());
		checkButton.interactable = false;
		solutionNumber.onValueChanged.AddListener(delegate {EnableButton(); });
		PlayGame(gameMode);
	}
\end{lstlisting}
In der \textit{Start} Funktion der Szene werden am Anfang ein Listener für den Menü-Button und einen für den Test Button zu gewiesen. In dieser Szene werden aus den statischen Variablen des Menüs davor der Spielmodus gespeichert. So weiß das Skript nun, ob es Addieren, Subtrahieren, Multiplizieren oder Dividieren laden soll. Der Button zum Testen wird am Anfang deaktiviert, da wenn das Eingabefeld leer ist und der Button gedrückt wird die Szene einfriert. Damit dieser verhindert wird, wird der Button beim Start der Szene deaktiviert. Wenn das Kind eine Zahl in das Eingabefeld eingibt, wird der Button aktiviert. Dies ist mit der \textit{onValueChange} Funktion für das Eingabefeld möglich, diese bekommt einen Listener der die Funktion EnableButton aufruft und dann den Button aktiviert oder deaktiviert. Als Letztes ruft die Startfunktion die Funktion \textit{PlayGame} aufgerufen. Diese wird mit dem Übergabeparameter des Gamemodes aufgerufen.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs EnableButton Funktion}]
	public void EnableButton(){
		if(string.IsNullOrEmpty(solutionNumber.text)){
			checkButton.interactable = false;
			solutionNumber.interactable = true;
		}
		else{
			checkButton.interactable = true;
		}
	}
\end{lstlisting}
Die \textit{EnableButton} Funktion überprüft bei jeder Änderung des Wertes, ob das Input Feld leer ist oder nicht. Dies erfolgt mit der \textit{IsNullOrEmpty} abfrage, da aber eine Integerzahl eingegeben wird, muss diese mit \textit{string.} in einen String umgewandelt werden. Wenn das Feld leer ist, wird der Button deaktiviert und das Eingabefeld aktiviert, sodass der Schüler/die Schülerin eine Eingabe tätigen kann. Wenn das Feld gefüllt ist, wird der Testbutton aktiviert. Damit in den jeweiligen Szenen keine falsche Eingabe gemacht werden kann, also bei den mathematischen Spielen kein Text und bei dem Deutschen Spiel keine Zahl eingegeben werden kann, wird in Unity die Eingabe auf den jeweiligen Wert festgelegt, dies ist in Abbildung 5.27 zu sehen.
\graphic{inputType}{Festlegen welcher Wert in das Input feld geschrieben werden darf}
Der Code der Funktion, die in das Menü zurückkehrt, wird nicht eingefügt, da etwas in dieser Art schon erklärt wurde. Dieser setzt die statischen Variablen auf den Ursprungswert zurück und lädt die Menüszene.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs PlayGame Funktion}]
public void PlayGame(int gameMode){
		countLvl++;
		if(countLvl > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", wrongSolution);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + wrongSolution);
		}
		//change color to white
		imageColor.color = new Color32(255, 255, 255, 255);

		if(countLvl <= lvlNumber)	showLevelNumber.text = "Level: " + countLvl + "/" + lvlNumber;
		solutionNumber.text = "";
		if(gameMode == 4){
			operatorSymbole.text = "/";
			minRandomNumber = 1;
			leftNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			rightNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			solution = leftNumber * rightNumber;
			SetNumbersLeftAndRight(solution, rightNumber);
			return;
		}
		else if(gameMode == 2){
			minRandomNumber = 0;
			leftNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			rightNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			if(leftNumber < rightNumber){
				Debug.Log(" leftNumber: " + leftNumber + " rightNumber: " + rightNumber + "zweite If");
				SetNumbersLeftAndRight(rightNumber, leftNumber);
				solution = rightNumber - leftNumber;
			}
			else{
				Debug.Log(" leftNumber: " + leftNumber + " rightNumber: " + rightNumber + "zweite If");
				SetNumbersLeftAndRight(leftNumber, rightNumber);
				solution = leftNumber - rightNumber;
			}
			operatorSymbole.text = "-";
			return;
		}
		else{
			minRandomNumber = 0;
			leftNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			rightNumber = RandomNumbers(minRandomNumber, maxRandomNumber);
			SetNumbersLeftAndRight(leftNumber, rightNumber);
			if(gameMode == 1){
				operatorSymbole.text = "+";
				solution = leftNumber + rightNumber;
			}
			else{
				operatorSymbole.text = "*";
				solution = leftNumber * rightNumber;
			}
			return;
		}
	}
\end{lstlisting}
Die \textit{PlayGame} Funktion, zählt den Zähler für die Anzahl der Level jeden Aufruf um eins nach oben. Das Skript teste dann, ob der Counter über der Anzahl zu spielenden Level ist, wenn dies der Fall ist, wird in einer Datei die Anzahl an Fehler gespeichert und die Szene, die den EndScreen lädt geladen. In diesem Fall speichern wir die Anzahl der Fehler nicht in eine Static Variable, weil bei der Implementierung am Anfang das die dem Entwickler einzige bekannte möglichkeit war und in diesem Fall die Variable aus dem File genutzt werden kann. Das hat den Vorteil, dass das Skript für die Szene nach Abschließen eines Levels keine statische Variable deklariert werden muss, sondern die aus der Datei verwendet werden kann.\\
Das Skript muss den Rahmen des Eingabefeldes beim Aufruf der \textit{PlayGame} Funktion wieder auf die Farbe Weiß setzten. Das Skript setzt die Anzahl an Level in das passende Textfeld, solange der Zähler nicht größer als die maximale Anzahl an Leveln ist. Bei jedem Aufruf der Funktion wird das Eingabefeld geleert, sodass keine Zahl in dem Feld steht.\\
Für jede Art der Grundrechenarten werden andere Vorbereitungen benötigt, um eine korrekte Rechnung zu erstellen. Wenn das Kind Dividieren soll, muss das Operator-Textfeld das Symbol \textit{/} anzeigen. Damit eine Division entsteht, die mathematisch korrekt ist, wird die möglichste kleinste Zahl die zufällig generiert werden kann auf eins gesetzt. Nachdem dieser Fall verhindert wird, werden zwei Zahlen für das Linke und Rechte Textfeld generiert und die Solution wird durch eine Multiplikation berechnet, der Grund dafür ist, dass wenn eine Zahl durch eine Multiplikation erzeugt wird und diese durch eine der beiden zufälligen Zahlen dividiert wird, auf jeden Fall keine Dezimalzahl als Ergebnis herauskommt. Daher wird das Ergebnis der Rechnung in das linke Feld und die rechten Zahlen in das rechte Feld geschrieben. Das Ergebnis ist in diesem Fall dann immer die Zahl, die für die linke Seite erzeugt wurde.\\
Im Falle einer Subtraktion werden wieder zufällige Zahlen erzeugt, dieses Mal ist die kleinste mögliche Zahl allerdings eine null. Damit das Ergebnis keine negativen Zahlen werden können, wird überprüft welche Zahl die größere ist, diese wird in die linke Seite geschrieben und die kleiner in die rechte Seite. Je nachdem, welcher Fall eintritt, wird die richtige Lösung berechnet.\\
Für den Fall der Addition und Multiplikation, können beide Zahlen unbesorgt für die Linke und Rechte Seite erzeugt werden. Hierbei sollte überhüpft werden, ist im Feld für den Operator ein plus oder ein Stern zu sehen  und wie die Lösung berechnet werden muss.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs RandomNumber Funktion}]
	public int RandomNumbers(int minRandomNumber, int maxRandomNumber){
		return UnityEngine.Random.Range(minRandomNumber, maxRandomNumber);
	}
\end{lstlisting}
In dieser Funktion wird eine zufällige Zahl mithilfe der von Unity bereitgestellten Funktion generiert. Die Funktion erzeugt eine zufällige Zahl in der Reichweite einer kleinstmöglichen Zahl und einer maximalen Zahl.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs SetTextLeftAndRight Funktion}]
	public void SetNumbersLeftAndRight(int left, int right){
			TextNumberLeft.text = left.ToString();
			TextNumberRight.text = right.ToString();
	}
\end{lstlisting}
Diese Funktion setzt die zwei übergebenen Zahlen auf in die linke und rechte Seite der Textfelder. Indem wir von dem Objekt \textit{Textfield} die Komponente \textit{.text} aufrufen, können wir in diese die Integerzahl, nachdem wir sie in einen String umgewandelt haben, einspeichern.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs ButtonClick Funktion}]
	public void buttonClick(){
		checkButton.interactable = false;
		if(gameMode == 4){
			StartCoroutine(waiterDiv(1));
		}
		else{
			StartCoroutine(waiter(1));
		}
	}
\end{lstlisting}
Wenn der Test Button gedrückt wurde, wird je nach Game Mode eine \textit{Coroutine} aufgerufen, diese wird verwendet, um zwischen den Leveln eine Sekunde zu warten und dem Kind zu zeigen sein Ergebnis ist falsch oder richtig. Da die Division anders überprüft werden muss, als die andern drei Rechenarten, bekam diese eine eigenen \textit{Coroutine}.\\
\begin{lstlisting}[language=csh, caption={MathOperations.cs waiter Funktion}]
	IEnumerator waiter(int sec){
		solutionNumber.interactable = false;
		if(countLvl <= lvlNumber){
			if(int.Parse(solutionNumber.text) == solution){
				//change color green
				imageColor.color = new Color32(37, 250, 53, 255);
				yield return new WaitForSeconds(sec);
				PlayGame(gameMode);
			}
			else{
				wrongSolution++;
				//change color red
				imageColor.color = new Color32(251, 37, 37, 255);
				yield return new WaitForSeconds(sec);
				//change color to white
				imageColor.color = new Color32(255, 255, 255, 255);
				solutionNumber.text = "";
			}
		}
	}
\end{lstlisting}
Dies ist die \textit{Coroutine} für alle Grundrechenarten außer der Division. Die beiden Funktionen sind sich aber sehr ähnlich, daher wird nur eine erklärt. Als Erstes wird das Eingabefeld deaktiviert, da schnell schreiben Kinder währen die Lösung anzeigt, dass das Ergebnis falsch ist schon die richtige Zahl eingeben können ohne zu warten bis dieser Ablauf einmal durchlaufen ist. Danach wird überprüft, ob das Kind überhaupt noch Level zuspielen hat. Wenn ja, wird das Ergebnis mit der Eingabe verglichen, wenn diese gleich ist, wird der Rahmen des Eingabefeldes für eine Sekunde Grün, danach wird das nächste Level geladen. Wenn das Kind falsch gerechnet hat, wird der Zähler für die Fehler hochgezählt und die Farbe des Rahmens wird für eine Sekunde rot, danach wird dieser wieder weiß gefärbt. Die Farbe eines Objektes kann geändert werden, indem von dem Objekt der Komponente \textit{.color} aufgerufen wird und eine neue Farbe zugewiesen bekommt, wie zum Beispiel \textit{new Color32(255, 255, 255, 255);} für die Weiße Farbe. Das Eingabefeld wird gelehrt, aber keine neue Rechnung geladen.\\
Der Unterschied zur Division Überprüfung ist, in der Abfrage, ob die Eingabe das gleich wie die Lösung ist, wird getestet, ob die Eingabe das gleiche wie die Zahl, die für das linke Feld generiert wurde.
\subsection{Szene - Mengen vergleichen}
\subsubsection{Mengen vergleichen - Design}
\graphic{quantitiesObjects}{größer, kleiner, gleich}
In dieser Szene gibt es zwei Möglichkeiten das Spiel zu spielen, entweder in den Feldern Links und Rechts, stehen Zahlen. Diese werden in der Mitte des weißen Vierecks angezeigt, oder in den Vierecken werden Objekte angezeigt, diese werden mithilfe einer \textit{Layout Group} in vier Reihen eingefügt. Der Header der Szene beinhaltet einen Menübutton, eine kleine Aufgabenstellung und die Level-Anzeige. In der Mitte der Szene befindet sich ein leeres Viereck, dieses zeigt an, welcher der unteren Buttons gedrückt wurde und ob die Lösung richtig oder falsch ist. Dies ist wieder mit einem grünen oder roten Rahmen umgesetzt. Ganz unten in der Szene gibt es drei verschiedene Buttons für die jeweilige Option größer, kleiner oder gleich. Die Buttons werden nach dem Auswählen einer Option deaktiviert, bis das nächste Level geladen hat oder bis das Kind erneut versuchen kann, die richtig zu bestimmten. Die Buttons mussten deaktiviert werden, da bei der richtigen Lösung auf den richtigen Button zehnmal gedrückt werden könnte und somit das Spiel nach einer Runde beendet wurde.\\
\subsubsection{Mengen vergleichen - Skript}
\begin{lstlisting}[language=csh, caption={GameQuantities.cs Variablen Deklaration}]
public class GameQuantities : MonoBehaviour {
	//the Textfields I fill
	public Text TextfieldLeft;
	public Text TextfieldRight;
	public Text TextfieldLevel;
	public Text Symbol;

	//collider for Objects
	public Collider2D spawnerLeftCollider;
	public Collider2D spawnerRightCollider;

	//my Gameobjects to compare Quantities
	public GameObject objectLeft;
	public GameObject objectRight;
	public GameObject spawnerLeft;
	public GameObject spawnerRight;
	private GameObject spawnedObject;

	//array with gameObjects
	private List<GameObject> alleQuantitiesObjects = new List<GameObject>(40);

	public Image imageColor;

	//Buttons
	public Button lessBtn;
	public Button equalsBtn;
	public Button greaterBtn;
	public Button menu;

	//variables for compare Quantities
	private int numberLeft = 0;
	private int numberRight = 0;
	private int randomNumber = 0;
	private int counterRound = 0;
	private int counterWrongChoice = 0;
	private Vector3 scaleSize = new Vector3 (1.0f, 1.0f, 1.0f);

	//number of lvls
	private int lvlNumber = 10;
	private int maxNumber = 0;

	//1 für mit objekten, 2 für mit zahlen
	private int lvlChoice = 1;
\end{lstlisting}
In dieser Szenen werden viele Variablen benötigt, diese einzeln zu erklären dauert zu lange. Die Szene benötigt, zwei Textfelder für die Zahlen Links und rechts, in diesen Vierecken existieren auch zwei leere Felder die als Spawner für die Objekte dienen. Eine Variable ist für das Zeichen des vergleichen. Das Skript benötigt vier Buttons, eine Liste für die erzeugten Objekte. Um die Zahlen, Objekte und den Spielmodus zu vergleichen, werden Variablen deklariert, die in den einzelnen Funktionen verwendet werden. Da auch in dieser Szene die erzeugten Objekte wieder zu klein erzeugt werden, wird ein weiterer Vektor benötigt, der diese auf die Originalgröße zurück skaliert.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs Start Funktion}]
	void Start() {
		menu.onClick.AddListener(() => GoBack());
		maxNumber = MenuPickLevelAdvanced.maxNumberStatic;
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		lvlChoice = MenuPickLevelAdvanced.fourChoices;
		lessBtn.onClick.AddListener(() => SetSymbol('<'));
		equalsBtn.onClick.AddListener(() => SetSymbol('='));
		Debug.Log("Lvl Ammount: " + lvlNumber);
		greaterBtn.onClick.AddListener(() => SetSymbol('>'));
		PlayGame();
	}
\end{lstlisting}
Die \textit{Start} Funktion erzeugt wieder für den jeweiligen Button einen Listener. Für die Buttons, mit der Auswahl der drei Zeichen, wird eine Funktion aufgerufen, die das aktuelle Symbol in das Textfeld in der Mitte setzt. Die statischen Variablen aus dem Menü davor werden wieder für die Anzahl an leveln verwendet und um zu kontrollieren, ob Zahlen oder Objekte erzeugt werden.\\

Die Funktion für das um in das Menü zurückzugehen wurde in den vorherigen Kapiteln schon erklärt.\\

\begin{lstlisting}[language=csh, caption={GameQuantities.cs SetSymbol Funktion}]
	public void SetSymbol(char symbol){
		lessBtn.interactable = false;
		equalsBtn.interactable = false;
		greaterBtn.interactable = false;
		Symbol.text = symbol.ToString();
		StartCoroutine(waiter(1, symbol));
	}
\end{lstlisting}
Die Funktion bekomme das Zeichen kleiner, gleich oder größer übergeben. Sobald einer der drei Buttons gedrückt wurde, werden alle drei Buttons deaktiviert, das Textfeld gesetzt und die \textit{Coroutine} zur Überprüfung des Ergebnisses aufgerufen.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs PlayGame Funktion}]
	public void PlayGame() {
		counterRound++;
		if(counterRound > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", counterWrongChoice);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + counterWrongChoice);
		}
		Debug.Log("Round: " + counterRound);
		lessBtn.interactable = true;
		equalsBtn.interactable = true;
		greaterBtn.interactable = true;
		//change color to white
		imageColor.color = new Color32(255, 255, 255, 255);
		if(counterRound <= lvlNumber)	SetLevelText();
		Symbol.text = "";
		if (lvlChoice == 2) {
			numberLeft = GenerateNumber(maxNumber);
			numberRight = GenerateNumber(maxNumber);
			SetTextLeftAndRight(numberLeft, numberRight);
		} else if (lvlChoice == 1) {
			numberLeft = GenerateNumber(16);
			numberRight = GenerateNumber(16);
			SpawnQuantitiesObjects(numberLeft, spawnerLeft, objectLeft);
			SpawnQuantitiesObjects(numberRight, spawnerRight, objectRight);
		}
	}
\end{lstlisting}
Die \textit{PlayGame} Funktion, zählt wieder für jeden Aufruf den Level Zähler nach oben und überprüft, ob genug Level gespielt wurden. Wenn das nicht der Fall ist, wird die aktuelle Level-Zahl angezeigt werden und die Buttons werden wieder aktiviert. Die Funktion ändert die Rahmenfarbe auf Weiß und leert das Feld mit dem Symbol wieder. Je nachdem welcher Modus gewählt wurde, werden die zwei zufällig generierten Zahlen als Zahl in die Felder geschrieben oder es werden maximal 16 Objekte für jede Seite erzeugt und angezeigt.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs SpawnQuantitiesObjects Funktion}]
	public void SpawnQuantitiesObjects(int number, GameObject spawner, GameObject side) {
		for (int i = 0; i < number; i++) {
			spawnedObject = Instantiate(side, spawner.transform.position, Quaternion.identity);
			spawnedObject.name += i;
			spawnedObject.transform.SetParent(spawner.transform.GetChild(i / 4));
			spawnedObject.transform.localScale = scaleSize;
			alleQuantitiesObjects.Add(spawnedObject);
		}
	}
\end{lstlisting}
Die Funktion bekommt als Übergabe eine Zahl, einen der beiden Bereiche, in denen die Objekte erzeugt werden sollen und das Objekt, das erzeugt werden soll, da dieses für Links ein anderes als für Rechts ist. Das Skript läuft eine \textit{For}-Schleife durch, die die gewünschte Zahl an Objekten erzeugen soll. Da in dieser Szene in jeder der Reihen nur vier Objekte passen, wird in die \textit{Layout-Group} an der Stelle i / 4 das Objekt gesetzt, so wird nach vier Objekten die nächste Reihe verwendet. Am Schluss der Funktion werden die Objekte in eine Liste gespeichert.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs Delete Funktion}]
	public void DeleteObjects() {
		foreach (GameObject child in alleQuantitiesObjects) {
			Destroy(child);
		}
	}
\end{lstlisting}
Die Objekte, die in die Liste gespeichert, werden nach dem Lösen eines Levels wieder gelöscht. Die Funktion iteriert mit einer \textit{foreach}-Schleife durch alle Objekte der Liste und löscht diese aus der Szene. Somit werden nicht nur immer mehr Objekte erzeugt.\\

Die nächsten drei Funktionen des Skriptes würden nur wieder zeigen, wie die Zufallszahlen erzeugt werden und wie die Textfelder der Levelanzahl und die Zahlen anzeigt werden sollen.\\

\begin{lstlisting}[language=csh, caption={GameQuantities.cs waiter Funktion}]
IEnumerator waiter(int sec, char symbol){
		if(counterRound <= lvlNumber ){
			if(symbol.Equals('<')){
				Symbol.text = '<'.ToString();
				if (numberLeft < numberRight) {
					Debug.Log("Richtig");
					//change color green
					imageColor.color = new Color32(37, 250, 53, 255);
					yield return new WaitForSeconds(sec);
					DeleteObjects();
					PlayGame();
				} else {
					counterWrongChoice++;
					//change color red
					imageColor.color = new Color32(251, 37, 37, 255);
					yield return new WaitForSeconds(sec);
					EnableButtons();
					imageColor.color = new Color32(255, 255, 255, 255);
					Symbol.text = "";
					Debug.Log("Nicht richtig");
				}
			}
			if(symbol.Equals('=')){
				Symbol.text = '='.ToString();
				if (numberLeft == numberRight) {
					Debug.Log("Richtig");
					//change color green
					imageColor.color = new Color32(37, 250, 53, 255);
					yield return new WaitForSeconds(sec);
					DeleteObjects();
					PlayGame();
				} else {
					counterWrongChoice++;
					//change color red
					imageColor.color = new Color32(251, 37, 37, 255);
					yield return new WaitForSeconds(sec);
					EnableButtons();
					imageColor.color = new Color32(255, 255, 255, 255);
					Symbol.text = "";
					Debug.Log("Nicht richtig");
				}
			}
			if(symbol.Equals('>')){
				Symbol.text = '>'.ToString();
				if (numberLeft > numberRight) {
					Debug.Log("Richtig");
					//change color green
					imageColor.color = new Color32(37, 250, 53, 255);
					yield return new WaitForSeconds(sec);
					DeleteObjects();
					PlayGame();
				} else {
					counterWrongChoice++;
					//change color red
					imageColor.color = new Color32(251, 37, 37, 255);
					yield return new WaitForSeconds(sec);
					EnableButtons();
					imageColor.color = new Color32(255, 255, 255, 255);
					Symbol.text = "";
					Debug.Log("Nicht richtig");
				}
			}
		}
	}
\end{lstlisting}
Die \textit{Coroutine} ist dafür zuständig zu überprüfen, ob die Zahl im linken Feld kleiner, gleich oder größer der Zahl im rechten Feld ist. Die Funktion überprüft zuerst, welches Symbol ausgewählt wurde, indem es das eingespeicherte Symbol mit den drei Möglichkeiten abgleicht. Danach wird geprüft, ob das Symbol für die jeweiligen erzeugten Zahlen korrekt ist. Wenn dies der Fall ist, wird der Rahmen des Symbolfeldes grün und nach einer Sekunde weiß. Danach werden die Objekte gelöscht und eine neue Runde wird geladen. Wenn das Kind die falsche Wahl getroffen hat, wird das Feld rot und die Fehleranzahl um eins hochgezählt. nach einer Sekunde werden die Buttons wieder aktiviert und die Farbe des Rahmens zurückgesetzt. Das Symbolfeld wird wieder geleert und das Kind kann erneut versuchen, das Problem zu lösen.\\
\begin{lstlisting}[language=csh, caption={GameQuantities.cs EnableButtons Funktion}]
	public void EnableButtons(){
		lessBtn.interactable = true;
		equalsBtn.interactable = true;
		greaterBtn.interactable = true;
	}
\end{lstlisting}
Diese Funktion aktiviert alle drei Buttons und wird aufgerufen, nachdem das Kind den falschen Button ausgewählt hat.
\subsection{Szene - Rechenmauer}
\subsubsection{Rechenmauer - Design}
\graphic{bottom5Tiles}{Rechenmauer mit fünf Steinen unten}
Die Rechenmauer kann in drei verschiedenen Varianten gespielt werden. Je nach dem Schwierigkeitsgrad, wird diese mit fünf, vier oder drei Steinen in der untersten Reihe erzeugt. Im Header ist die Szene wie die Anderen aufgebaut. In der Mitte wird die Mauer angezeigt, für diese wurde ein Prefab eines Steines angelegt, dieses wird dann mithilfe einer \textif{Layout Group} an die richtige Position gesetzt. Die Felder, die die unterste Reihe bilden, werden deaktiviert, damit der Nutzer diese nicht verändern kann. Wenn das Kind Felder den Test Button drückt, werden die richtigen Felder auch deaktiviert, damit diese nicht wieder verfälscht werden können. Die falschen Steine werden geleert und das Kind muss die Lösung erneut eintragen. Dies ist in der Abbildung 5.30 zu sehen.\\
\graphic{rechenmauerRichtigUndFalsch}{ Richtig und falsch gelöste Steine}
Wenn der Schüler/die Schülerin die Rechenmauer komplett richtig gelöst hat, wird das anhand des Feuerwerks, das um den Test Button auftaucht angezeigt. Die Pyramide wird geleert und eine neue unterste Reihe wird erzeugt. Das Feuerwerk wird auch in dem Spiel \textit{Führe die Reihe fort} angewendet und ist in Abbildung 5.31 zu sehen.
\graphic{finisheTriangle}{Feuerwerkt nach richtigem Lösen}
\subsubsection{Rechenmauer - Skript}
\begin{lstlisting}[language=csh, caption={Triangle.cs Variablen Deklaration}]
public class Triangle : MonoBehaviour
{

	public GameObject brick;

	//rows of the triangle
	public GameObject triangleGameObject;

	public Text lvlText;


	private GameObject spawnedObject;

	public GameObject leftFirework;
	public GameObject rightFirework;

	public GameObject fireworkPrefab;

	//3 = bottom 3 bricks, 4 = bottom 4 bricks, 5 = bottom 5 bricks
	private int triangleSize = 3;

	private int[][] jaggedSolution = new int[5][];

	private InputField[][] jaggedInputs = new InputField[5][];

	private int[] bottomNumbers;

	public Button testSolution;
	public Button menu;

	private int lvlCounter = 0;
	private int wrongChoice = 0;
	private int lvlNumber = 10;
	private int maxNumber = 0;
	private Vector3 scaleSize = new Vector3 (1.0f, 1.0f, 1.0f);
\end{lstlisting}
Im Skript der Rechenmauer benötigen wir eine Variable für das Prefab des einzelnen Steines. Die Rechenmauer wird in einem \textit{Layout Group} gespawnt, diese befindet sich in einem leeren Objekt. Es gibt auch hier wieder ein Textfeld, um das aktuelle Level anzuzeigen und ein Objekt, in das die Blöcke erzeugt werden. Für das Feuerwerk wird auch ein Objekt und zwei Positionen benötigt. Für die einzelnen Reihen gibt es 2 dimensionale Arrays, um die Lösung zu berechnen und um die Eingaben zu speichern. In der Szene gibt es zwei Buttons. Zum Abschluss benötigen wir noch ein paar private Variablen, die um das Level auszuführen notwendig sind. Diese wären die einen Zähler für das Level, einen Zähler für die Fehler. Die Anzahl an Level, die Maximal größte Zahl und einen Vektor um die Steine zur Originalgröße zu skalieren.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs Start-Funktion}]
	void Start()
	{
		menu.onClick.AddListener(() => GoBack());
		maxNumber = MenuPickLevelAdvanced.maxNumberStatic;
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		triangleSize = MenuPickLevelAdvanced.wallSize;
		testSolution.interactable = false;
		testSolution.onClick.AddListener(() => CheckSolution());
		jaggedInputs[0] = new InputField[1];
		jaggedInputs[1] = new InputField[2];
		jaggedSolution[0] = new int[1];
		jaggedSolution[1] = new int[2];
		GenerateSolutionArray();
		SpawnPyramidRows();
		PlayGame();
	}
\end{lstlisting}
Die \textit{Start} Funktion weißt den Buttons den listener zu und deaktiviert den Test Button. Die Spitze und die zwei Felder der Mauer, die unter dem obersten Stein liegen, werden immer erzeugt, da diese immer verwendet werden. Die 2-Dimensionalen Arrays werden an der ersten und zweiten Stelle in der Richtigen Größe Initalisiert. Danach wird die Funktion \textit{GenerateSolutionArray()} aufgerufen, diese initailiser die restlichen Ebenen des Lösungsarray und des Eingabearrays. Nachdem das Lösungsarray generiert wurde, werden die Reihen der Pyramide in die Szene geladen. Am Schluss wird die Funktion \textit{PlayGame()} aufgerufen, diese startet das Spiel für die Kinder.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs Update-Funktion}]
	void Update(){
		bool enabel = false;
		for (int i = 0; i < triangleSize - 1; i++){
			for (int j = 0; j < jaggedInputs[i].Length; j++) {
				if(string.IsNullOrEmpty(jaggedInputs[i][j].text)){
					enabel = true;
					testSolution.interactable = false;

				}
			}
		}
		if(!enabel){
			testSolution.interactable = true;
		}
	}
\end{lstlisting}
In dem Skript für die Rechenmauer und in der in dem das Kind die Reihe vervollständigen muss, wird die \textit{Update()} Funktion genutzt, um zu überprüfen, ob alle Eingabefelder gefüllt sind. Wenn eins der Felder leer ist, wird der Testbutton nicht aktiviert. In anderen Szenen wurde dies mit der Funktion \textit{onValueChanged} gelöst, aber um mehrere Felder zu überprüfen ist die Variante in der \textit{Update} Funktion angenehmer. In diesem Skript, läuft in der \textit{Update} Funktion eine doppelte \textit{For}-Schleife durch, diese läuft für jede Zeile die Länge ab und kontrolliert ob eines der Felder leer ist. Wenn ein Feld leer ist, wird die \texit{boolean} Variable auf true gesetzt, solange diese nicht false ist, wird der Test Button nicht aktiviert.\\
Die Funktion für den Menübutton wird wieder nicht erklärt.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs GenerateSolutionArray-Funktion}]
	public void GenerateSolutionArray(){
		if(triangleSize >= 3){
			jaggedSolution[2] = new int[3];
			jaggedInputs[2] = new InputField[3];
			if(triangleSize >= 4){
				jaggedSolution[3] = new int[4];
				jaggedInputs[3] = new InputField[4];
				if(triangleSize == 5){
					jaggedSolution[4] = new int[5];
					jaggedInputs[4] = new InputField[5];
				}
			}
		}
	}
\end{lstlisting}
In dieser Funktion wird kontrolliert, welche Größe die unterste Reihe der Pyramide hat, je nach der Größe werden die einzelnen Ebenen des 2-Dimensionales Arrays mit der passenden Größer deklariert. Zeitgleich wird das Array für die Eingaben des Kindes erzeugt, somit sind die beiden Array gleich groß.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs ShowBottomLineNumbers-Funktion}]
	public void ShowBottomLineNumbers(){
		for (int i = 0; i < bottomNumbers.Length; i++){
			if(triangleSize == 3){
				jaggedSolution[2][i] = bottomNumbers[i];
				jaggedInputs[2][i].text = bottomNumbers[i].ToString();
				jaggedInputs[2][i].interactable = false;
			}
			else if(triangleSize == 4){
				jaggedSolution[3][i] = bottomNumbers[i];
				jaggedInputs[3][i].text = bottomNumbers[i].ToString();
				jaggedInputs[3][i].interactable = false;
			}
			else if(triangleSize == 5){
				jaggedSolution[4][i] = bottomNumbers[i];
				jaggedInputs[4][i].text = bottomNumbers[i].ToString();
				jaggedInputs[4][i].interactable = false;
			}
		}
\end{lstlisting}
In dieser Funktion wird die unterste Reihe gefüllt. Je nach Größe der untersten Reihe, gibt drei \textit{If}-Statements, dies überprüfen in der \textit{For}-Schleife, wie groß die Untersteinreihe ist und füllt in diese aus einem Array, das für die unterste Reihe zufällige Zahlen generiert an die passende Stelle ein. Die Funktion dafür wird später erklärt. Die Nummer aus dem Array, wird auch sofort in das Eingabearray eingefügt, da diese Reihe für Kinder nicht bearbeitbar ist, aber die Kontrolle zwischen dem Eingabearray und dem Lösungsarray so einfacher ist. Jedes Feld aus dem Eingabearray, in dem eine Zahl aus der untersten Reihe, steht, wird deaktiviert.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs FillSolutionArray-Funktion}]
	public void FillSolutionArray(){
		for (int i = triangleSize - 2; i >= 0; i--){
			for (int j = 0; j < jaggedSolution[i].Length; j++){
				jaggedSolution[i][j] = jaggedSolution[i + 1][j] + jaggedSolution[i + 1][j + 1];
			}
		}
	}
\end{lstlisting}
In dieser Funktion werden die Lösungen berechnet und an die richtige Position gespeichert. Dafür werden zwei \textit{For}-Schleifen benötigt. Um die Lösung zu berechnen, werden zwei Nebeneinader liegende Felder verwendet. Die äußere \textit{For}-Schleife zählt die Variable i nach unten, die innere zählt nach oben. Dies wurde so implementiert, da wir die Pyramide von unten nach oben berechnen müssen. Deswegen wurde i mit der Pyramiedengröße - 2 belegt. Weil die Schleife bis zu Zahl null durchlaufen muss und weil die unterste Reihe schon gefüllt ist. Die zweiten schleife, geht in den einzelnen Reihen einfach durch und berechnet die Lösungen.\\
Die Funktion, die für den Test Button aufgerufen wird, ist eine Zeile, diese startet die \textit{Coroutine}, um die Ergebnisse zu überprüfen.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs PlayGame-Funktion}]
	public void PlayGame(){
		lvlCounter++;
		if(lvlCounter > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", wrongChoice);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + wrongChoice);
		}
		if(lvlCounter != 1){
			Debug.Log("hier war ich");
			ClearArray();
		}
		if(lvlCounter <= lvlNumber)	lvlText.text = "Level: " + lvlCounter + "/" + lvlNumber;
		GenerateNumbers();
		ShowBottomLineNumbers();
		FillSolutionArray();
	}
\end{lstlisting}
Diese Funktion zählt einen Zähler nach oben, um zu sehen, welches Level das Kind spielt, um die Szene nach Abschluss des Spieles zu laden. Wenn der Zähler größer als die Zahl eins ist, wird die Mauer mit jedem Aufruf der \textit{PlayGame}-Funktion geleert. Wenn der Zähler kleiner als die maximale Anzahl an leveln ist, wird das Textfeld aktualisiert, die zufälligen Zahlen werden erzeugt. Danach wird die unterste Reihe gefüllt und das Lösungsarray berechnet.\\ 
\begin{lstlisting}[language=csh, caption={Triangle.cs ClearArray-Funktion}]
	public void ClearArray(){
		for (int i = 0; i < triangleSize - 1; i++){
			for (int j = 0; j < jaggedInputs[i].Length; j++) {
				jaggedInputs[i][j].text = "";
				jaggedInputs[i][j].interactable = true;
			}
		}
	}
\end{lstlisting}
Um das Array zu leeren, wird mithilfe einer doppelten \textit{For}-Schleife, jedes Feld der Mauer durchgegangen, diese werden geleert und wieder aktiviert, sodass das Kind diese wieder füllen kann.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs SpawnPyramidRows-Funktion}]
	public void SpawnPyramidRows(){
		for (int i = 0; i < triangleSize; i++){
			for (int j = 0; j < i + 1; j++){
				spawnedObject = Instantiate(brick, triangleGameObject.transform.position, Quaternion.identity);
				spawnedObject.name += i;
				spawnedObject.transform.SetParent(triangleGameObject.transform.GetChild(i));
				spawnedObject.transform.localScale = scaleSize;
				jaggedInputs[i][j] =spawnedObject.GetComponent<InputField>();
			}
		}
	}
\end{lstlisting}
Um die Reihen der Mauer zu erzeugen, wird wieder eine doppelte \textit{For}-Schleife benötigt. Diese läuft die variable \textit{triangleSize} durch und füllt in jedes freie Feld der \textit{Layout Group} einen Stein ein. Das Erzeugen der Mauer läuft nach dem gleichen Prinzip ab, nachdem die Objekte bei den Mengenvergleichen oder bei dem Spiel Blitzblick erzeugt werden. Erst werden diese Instantiated, dafür wird das GameObject des Steines benötigt. Danach brauchen wir ein Feld, in das wir den Stein setzten, sollen, die Rotation ist in diesem Fall wieder unwichtig. Die Objekte bekommen für die Hirachy einen Namen und werden an die passende Kinderposition gesetzt. Da die Steine zu klein skaliert werden, wird die Skalierung auf eins zurückgesetzt. Als letztes, werden die Prefabs der Eingabefelder in das Array aus Eingabefeldern eingefügt.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs GenerateNumbers-Funktion}]
	public void GenerateNumbers(){
		bottomNumbers = new int[triangleSize];
		for (int i = 0; i < bottomNumbers.Length; i++) {
			bottomNumbers[i] = UnityEngine.Random.Range(0, maxNumber);
			jaggedSolution[triangleSize - 1][i] = bottomNumbers[i];
		}
	}
\end{lstlisting}
Diese Funktion, deklariert die größe eines normalen Arrays, diese beinhaltet die größe der untersten reihe. In einer \textit{For}-Schleife, wird für jedes Feld in diesem Array eine zufällige Zahl mit der \textit{UnitEngine.Random.Range}-Funktion generiert. Diese wird in die unterste Reihe des Arrays, das alle Lösungen speichert eingefügt.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs SpawnFirework-Funktion}]
	public void SpawnFirework(){
		spawnedObject = Instantiate(fireworkPrefab, leftFirework.transform.position, leftFirework.transform.rotation);
		spawnedObject.transform.SetParent(leftFirework.transform);
		spawnedObject.transform.localScale = scaleSize;
		spawnedObject = Instantiate(fireworkPrefab, rightFirework.transform.position, rightFirework.transform.rotation);
		spawnedObject.transform.SetParent(rightFirework.transform);
		spawnedObject.transform.localScale = scaleSize;
		Debug.Log("Firework");
	}
\end{lstlisting}
Diese Funktion, deklariert die Größe eines normalen Arrays, diese beinhaltet die Größe der untersten Reihe. In einer \textit{For}-Schleife wird für jedes Feld in diesem Array eine zufällige Zahl mit der \textit{UnitEngine.Random.Range}-Funktion generiert. Diese wird in die unterste Reihe des Arrays, das alle Lösungen speichert, eingefügt.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs DeleteFirework-Funktion}]
	public void DeleteFirework(){
		Destroy(leftFirework.transform.GetChild(0).gameObject);
		Destroy(rightFirework.transform.GetChild(0).gameObject);
	}
\end{lstlisting}
Damit das Feuerwerk nach der einen Sekunde wieder verschwindet, wird die Funktion \textit{DeleteFirework} aufgerufen, diese löscht aus den beiden eigentlich leeren Objekten \textit{leftFirework} und \textit{rightFirework} die Prefabs der Feuerwerke gelöscht.\\
\begin{lstlisting}[language=csh, caption={Triangle.cs Waiter-Funktion}]
	IEnumerator Waiter(int sec){
		bool finished = false;
		if(lvlCounter <= lvlNumber){
			for (int i = triangleSize - 2; i >= 0; i--){
				for (int j = 0; j < jaggedSolution[i].Length; j++){
					if(jaggedSolution[i][j] == int.Parse(jaggedInputs[i][j].text)){
						jaggedInputs[i][j].interactable = false;
						continue;
					}
					else{
						jaggedInputs[i][j].text = "";
						wrongChoice++;
						finished = true;
					}
				}
			}
			if(!finished){
				SpawnFirework();
				yield return new WaitForSeconds(sec);
				DeleteFirework();
				PlayGame();
			}
		}
	}
\end{lstlisting}
Hier wird überprüft, ob die Mauer komplett richtig gerechnet wurde. Dafür wird eine \textit{Boolean} Variable benötigt, diese ist standardmäßig mit false implementiert. Nachdem die Funktion getestet hat, ob das Kind noch nicht alle Level gespielt hat, wird mit einer doppelten \textit{For}-Schleife überprüft, ob die Eingabe des Kindes die gleiche ist, wie die Zahlen in dem Lösungsarray. Wenn ein Ergebnis richtig ist, wird das Eingabefeld deaktiviert und die Schleife springt ein Durchgang weiter. Wenn eine der Eingabe nicht richtig ist, wird das Feld geleert, der Fehlerzähler wird eins nach oben gezählt und die Variabel \textit{finished} wird auf true gesetzt. Wenn die Variabel false ist, wurde die gesamte Mauer gelöst, also wird das Feuerwerk mit dem Aufruf der Funktion \textit{SpawnFirework()} erzeugt. Dann wartet das Skript mithilfe des \textit{yield return new WaitForSeconds(sec)} eine Sekunde, danach wird das Feuerwerk mit der \textit{DeleteFirework()} gelöscht. Als Letztes wird die \textit{PlayGame()} aufgerufen und damit eine neue Mauer generiert.\\
\subsection{Szene - Blitzblick}
\subsubsection{Blitzblick - Design}
\graphic{lightningViewWithoutCover}{Blitzblick ohne Vorhang}
\graphic{lightningViewCover} Blitzblick mit Vorhang}
Die Szene ist hier in zwei Bildern gezeigt. In der Abbildung 5.32 ist die Szene ohne den Vorhang zu sehen und in der Abbildung 5.33 mit dem Vorhang. Das Spiel Blitzblick, zeigt dem Schüler/der Schülerin, eine anzahl an Objekten und verdeckt diese danach. Das Kind, müss dann sehr schnell sehen, wie viele der Objekte angezeigt wurden und diese in ein Textfeld eingeben. Wenn das Kind den Testbutton auswählt wird die Zahl überprüft und wenn es richtig lag wird eine neue runde geladen. Wenn das Kind die falsche anzahl angiebt, bekommt es die Objekte nocheinmal für eine Sekunde zu sehen. Die zeit wie lange die Objekte zu sehen sind, wird nicht verringert oder ehrhöht, da eine sekunde für die vorhergesene Anzahl an Objekten schon schwer ist.\\
Die Szene hat einen Header wie jede andere, in diesem ist ein Menü Button, eine überschrift und die Levelanzahl zu sehen. In der Mitte der Szene ist das Feld indem die Objekte auftauchen, dieses wird von einem grünen Vorhang verdeckt. Rechts davon ist das Eingabefeld für den Nutzer. Ganz unten in der Szene ist der Button zum testen seiner lösung. Dieser ist solange keine Zahl eingegeben wurde deaktiviert. In dieser Szene wird dem Schüler/der Schülerin durch einen grünen Rahmen angezeigt ob die Lösung richtig oder falsch ist.\\
\subsubsection{Blitzblick - Skript}
\begin{lstlisting}[language=csh, caption={lightningView.cs Variablen Deklaration}]
public class lightningView : MonoBehaviour {

	public Text showLevel;

	public InputField solution;

	public Image imageColor;

	public GameObject spawnedObject;
	public GameObject spawner;
	public GameObject cover;
	private GameObject allObjects;

	public GameObject spawnerCoverLeft;

	public Button checkButton;
	public Button menu;

	private List<Vector2> allPositions = new List<Vector2>(10);

	//Variabln for lightningView
	private int numberLeft;
	private int counterRound = 0;
	private int wrongChoice = 0;
	private int lvlNumber = 10;
	private float minDistance = 0f;
	private bool hitPosition = false;
	private Vector3 scaleSize = new Vector3 (1.0f, 1.0f, 1.0f);
\end{lstlisting}
Für dieses Spiel benötigen wir wieder ein Textfeld um das Level anzuzeigen. Die Szene benötigt, auch ein Eingabefeld und ein Objekt um die Farbe des Rahmens zu ändern. Da in diesem Skript wieder Objekte erzeugt werden, wird ein Bereich in denen diese auftauchen sollen festglegt. In Unity wurde ein Prefab der Objekte vorbereitet. Damit der Vorhang über den Objekten zu sehen ist, wird dieser auch durch ein Prefab geladen. In diesem Skript werden die Objekte an zufälligen Postiionen erzeugt, damit diese nicht aufeinander liegen, wird die position in eine Vektor Liste eingespeichert. Um das Spiel zu Managen, werden ein paar \textit{private} Attribute benötigt. Um zu unterscheiden wie groß die Minimal Distanz sein soll, wurde eine Variable deklariert. Um eine Überschneidung zu finden, benötigti das Skript eine Boolean variable. Die Objekte werden auch in diesem Fall wieder zu klein Skaliert, deswegen wird wieder ein Vektor mit der standartgröße festgelegt\\
\begin{lstlisting}[language=csh, caption={lightningView.cs Start-Funktion}]
	void Start() {
		minDistance = spawnedObject.GetComponent<RectTransform>().rect.width / 2;
		spawner.transform.localScale = scaleSize;
		checkButton.interactable = false;
		menu.onClick.AddListener(() => GoBack());
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		checkButton.onClick.AddListener(() => buttonClick());
		solution.onValueChanged.AddListener(delegate {EnableButton(); });
		playGame();
	}
\end{lstlisting}
Diese \textit{Start} Funktion, legt als erstes die Minimale Distanz fest, die ein Objekt zu einem anderen Objekt besitzen darf. Diese wird wie folgt berechnet. Das Skript holt sich von dem Prefab Objekt \textit{spawnedObject} ein Rechteck. Der befehlt \textit{.GetComponent<RectTransform>().rect.width} sucht sich aus dem Prefab das rechteck und nimmt von diesem die Breite. Die Minimale Distanz zwischen den Objekten ist die hälfte des bekommenen Rechtecks. Danach wird der Bereich für die Objekte auf die Originalgröße skaliert, da dieser nicht mit Skaliert wurde. Das heißt im Vollbildmodus wurde dieser nicht größer. Der Testbutton wird wieder Deaktiviert. In dieser Szene werden von den Statischen Variablen, nur die Levelanzahl verwendet. Das Feld der Objekte, kann nur eine gewisse Anzahl an Objekten beinhalten und diese Zahl darf auch für die Kinder nicht zu groß werden. Um zu überprüfen ob das Kind etwas in das Eingabefeld eingegeben hat, wird die \textit{onValueChange} Methode verwendet. Als letztes wird die \textit{playGame()} aufgerufen.\\
Die nächsten zwei Funktionen des Skriptes, laden das Menü und Aktivieren oder Deaktiviern den Test Button, diese sind ähnlich und werden deswegen nicht mehr genauer erläutert.\\
\begin{lstlisting}[language=csh, caption={lightningView.cs buttonClick-Funktion}]
	public void buttonClick(){
		checkButton.interactable = false;
		foreach (Transform child in spawnerCoverLeft.transform) {
			Destroy(child.gameObject);
		}
		StartCoroutine(solutionWaiter(1));
	}
\end{lstlisting}
Diese Funktion wird beim aufruf des Test Buttons durchlaufen, da in dieser Szene über den Objekten ein Vorhang schwebt, wird dieser einmal gelöscht und die \textit{Coroutine} die die Lösung überprüft wird aufgerufen.\\
Auch die Funktion für die Zufallszahlen wird nicht genauer erklärt. In diesem Spiel, wurde die Maximale Zahl auf die zehn gesetzt. Da mehr Objekte das Feld nicht beinhalten können und Kinder nicht zu viele Objekte in so kurzer Zeit erkennen können.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs buttonClick-Funktion}]
	public void hideCircle(){
		StartCoroutine(waiter(1));
	}
	
	IEnumerator waiter(int sec){
		solution.interactable = false;
		yield return new WaitForSeconds(sec);
		GameObject hideCircles = Instantiate(cover, spawnerCoverLeft.transform.position, Quaternion.identity);
		hideCircles.transform.SetParent(spawnerCoverLeft.transform);
		hideCircles.transform.localScale = scaleSize * (0.75f);
		solution.interactable = true;
	}
\end{lstlisting}
Um den Vorhang nicht direkt am anfang zu erzeugen, wird eine weiter \textit{Coroutine} geladen, diese deaktiviert das Eingabefeld für den Nutzer solange bis der Vorhang aufgetaucht ist, dies hat den Vorteil, dass der Nutzer nicht schon direkt die Zahl eintragen kann sonder wirklich eine Sekunde warten muss. Danach wird wie in anderen Szenen das Objekt erzeugt. Da der Vorhang aber erst zu klein war und in der Originalengröße zu groß ist, wird diese mit 0.75 multipliziert.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs setObjects-Funktion}]
	public void setObjects(){
		Debug.Log(numberLeft);
		for (int i = 0; i < numberLeft; i++) {
			allObjects = Instantiate(spawnedObject, spawner.transform.position, Quaternion.identity);
			allObjects.name += i;
			allObjects.transform.SetParent(spawner.transform);
			allObjects.transform.localScale = scaleSize;
			ChangePosition(i);
		}
	}
\end{lstlisting}
Hier werden für die zufällig generierete Zahl die Objekte mithilfe einer \textit{For}-Schleife generiert. Diese werden auf die Normale größe skaliert und danach wird die Funktion \textit{ChangePosition(i)} aufgerufen.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs ChangePosition-Funktion}]
	public void ChangePosition(int firstNumber){
		RectTransform spawnRect = spawner.GetComponent<RectTransform>();
		float width = spawnRect.rect.width;
		float height = spawnRect.rect.height;
		float xPos = UnityEngine.Random.Range(-width/2 + minDistance, width/2 - minDistance);
		float yPos = UnityEngine.Random.Range(-height/2 + minDistance, height/2 - minDistance);
		Vector2 newPos = new Vector2(xPos, yPos);
		Debug.Log("x:" + xPos);

		if(firstNumber == 0){
			allPositions.Add(newPos);
			allObjects.transform.localPosition = newPos;
			return;
		}


		for (int i = 0; i < allPositions.Count; i++){
			float distance = Vector2.Distance(new Vector2(allPositions[i].x, allPositions[i].y), new Vector2(newPos.x, newPos.y));
			if(distance >= minDistance){
				hitPosition = true;
			}
			else{
				hitPosition = false;
				break;
			}

		}
		if(hitPosition){
			allPositions.Add(newPos);
			allObjects.transform.localPosition = newPos;

		}
		else{
			ChangePosition(firstNumber);
		}

	}
\end{lstlisting}
Hier wird eine zufällige Position in dem Rechteck \textit{spawner} erzeugt. Dafür, bekommt ein Objekt \textit{RectTransform} das Rechteck des \textit{spawner}. Von diesem Objekt, werden die breite und höhe in Variablen gespeicehrt. Dann wird für die X-Position und Y-Position eine Random Zahl erzeugt. Die X-Position wird aus der Breite berechnet. Die kleinste mögliche Zahl befindet sich an der Stelle \textit{-width/2 + minDistance}, die maximale Zahle befindet sich an der Stelle \textit{width/2 - minDistance}. Es muss die negative breite geteilt durch zwei sein, da das Skript vom Mittelpunkt des Objektes ausgeht, also muss erst die breite geteilt werden und danach ist die negative zahl davon ganz links. Damit das Objekt nicht auf dem Rand des Rechtecks spawned, wird die minimale Distanz der Objekte daraufgerechnet. Für den ganz rechten Rand des Rechtecks, wird die positive breite geteilt und minus die minimale Distanz gerechnet. Für die Y-Position, wird die gleiche Rechnung benötigt. Nur das ansatt der breite die höhre des Rechtecks verwendet wird. Nachdem die beiden Positionen zufällig erzeugt wurden, werden diese in einen Vektor gespeichert. Wenn die Übergabe variable eine null ist, also wenn die \textit{For}-Schleife bei dem ersten durchlaufen ist, wird die Position die im Vektor \textit{newPos} gespeichert wurde in eine Liste gespeichert. Danach wird das Objekt an diese position bewegt und die Funktion mithilfe des Befehelt \textit{return} verlassen.\\
Wenn das nicht der erste druchlauf ist, wird mithilfe einer \textit{For}-Schleife, für das Aktuelle Objekt zuerst die Distanz zwischen allen Objekten und der neuen Position berechnet. Die Methode \textit{.Distance} bekommt zwei Vektoren, mit den X und Y werden der Position übergeben und berechnet einen Vektor der die Distanz beinhaltet. Wenn die Distanz dann größer oder gleich unsere minimal Distanz ist, wurde eine Position gefunden, die genutzt werden kann um das Objekt zu platzieren. Wenn das nicht der fall ist, wird die Boolean Variable auf false gesetzt und die Schleife verlassen. In deisem fall wird durch eine Abfrage die Funktion \textit{ChangePosition(firstNumber)} erneut aufgerufen. Wenn die Variable \textit{hitPosition} true ist, wird die neu gefundene Position in die Liste gespeichert und das Objekt an die besagte Position bewegt.\\
Die Funktion die die Objekte wieder löscht, ist die Selbe, die die Objekte in dem Spiel größer,kleiner, gleich löscht. Diese geht mithilfe einer \textit{foreach}-Schleife alle Objekte durch und löscht diese.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs playGame-Funktion}]
	public void playGame(){
		counterRound++;
		if(counterRound > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", wrongChoice);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + wrongChoice);
		}
		//change color to white
		imageColor.color = new Color32(255, 255, 255, 255);
		if(counterRound <= lvlNumber)	showLevel.text = "Level: " + counterRound + "/" + lvlNumber;
		numberLeft = randomNumber();
		Debug.Log(numberLeft);
		solution.text = "";
		setObjects();
		hideCircle();
	}
\end{lstlisting}
Die Funktion \textit{playGame} arbeit ähnlich zu den anderen, zuerst wird der Level zähler hochgezählt und geteste, ob das Kind noch level spielen sollte. Wenn nicht wird die Szene für den Abschluss geladen. Die Farbe des Rahmens wird wieder auf weiß gesetzt und ein neues level wird generiert. Dafür muss das Eingabefeld geleert werden und neue Objekte zufällig erzeugt werden. Als abschluss, muss der Vorhang wieder auftauchen.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs solutionWaiter-Funktion}]
	IEnumerator solutionWaiter(int sec){
		solution.interactable = false;
		if(counterRound <= lvlNumber){
			if(int.Parse(solution.text) == numberLeft){
				//change color green
				imageColor.color = new Color32(37, 250, 53, 255);
				yield return new WaitForSeconds(sec);
				deletObjects();
				playGame();

			}
			else{
				//change color red
				imageColor.color = new Color32(251, 37, 37, 255);
				yield return new WaitForSeconds(sec);
				wrongChoice++;
				//change color to white
				imageColor.color = new Color32(255, 255, 255, 255);
				solution.text = "";
				hideCircle();
			}
		}
	}
\end{lstlisting}
Diese \textit{Coroutine} deaktiviert das Eingabefeld und überprüft ob die eingebene Zahl die selbe ist, wie die zufällig generierte. Wenn das der Fall ist, wird der Rahmen grün und nach einer Sekunde werden die Objekte gelöscht und eine neue Runde mit der \textit{playGame()} Funktion gestartet. Wenn das Kind falsch liegt, wird der Rahmen für eine Sekunde rot und danach wieder Weiß, das eingabefeld wird geleert und die Objekte werden wieder versteckt.
\subsection{Szene - Vervollständigen die Reihe}
\subsubsection{Vervollständigen die Reihe - Design}
\graphic{finishPattern}{Verfolständige die Reihe}
In dieser Szene muss das Kind eine vorgegebene Reihe erkennen und fortführen. Den Kindern werden fünf Zahlen vorgegeben und aus dieser Reihe müssen sie die Schritte die die Zahlen machen erkennen und anwenden. Die Szene hat einen Header der gleich aufgebaut ist wie in den anderen Szenen. In der Mitte der Szene befinden sich insgesamt zehn feldern, in der Oberen Reihe, sind dies fünf Textfelder. Diese zeigen die Reihe an. In der unteren reihe, befinden sich fünf Textfelder die den Platzhalter Zahl haben. In diese können die Kinder ihre Zahlen eingeben. Der Testbutton wird auch in dieser Szene erst aktiviert, wenn alle Eingabefelder eine Zahl beinhalten. Diese Felder können keine anderen Zeichen als Zahlen enthalten. Dem Schüler/der Schülerinn, wird auch in dieser Szene anhand eines Feuerwekes gezeigt, ob es alle Felder richtig ausgefüllt hat. In Abbildung 5.31 ist das erwähnte Feuerwekt zu sehen. Das Spiel wurde so implementiert, das eine Zufällige Zahl erzeugt wird und mit zwei weiteren Zufallszahlen die Reihe fortgesetzt wird. Es wurde sich gegen noch mehr zufallszahlen entschieden, damit die Schüler/Schülerinnen keine zu Komplexen reihen bekommen. Es wurde aber so implementiert, das in den Unterschiedlichen Schwierigkeitsgraden die anfangszahl größer werden kann und auch die Zahlen die die Reihe Fortzusetzten werden größer.
\subsubsection{Vervollständigen die Reihe - Skript}
\begin{lstlisting}[language=csh, caption={hideCircle.cs Variablen Deklaration}]
public class FinishPattern : MonoBehaviour {

	public Text lvlText;

	//random Numbers
	private int randomNumber;
	private int FirstRandomNumber;
	private int SecondRandomNumber;

	//lvl variabls
	private int lvlNumber = 10;
	private int wrongAnswers;
	private int lvlCounter = 0;
	private int maxNumbers = 20;

	//int start start pattern
	private int[] patternNumbers = new int[5];

	//int solutions
	private int[] solutionsNumbers = new int[5];


	//Button test
	public Button checkSolution;
	public Button menu;

	//Firework
	private GameObject spawnedObject;
	public GameObject leftFirework;
	public GameObject rightFirework;
	public GameObject fireworkPrefab;

	public InputField[] arrayInputs = new InputField[5];
	public Text[] arrayTextFields = new Text[5];
\end{lstlisting}
Für diese Spiel werden mehrer zufällige Zahlen benötigt. Eine um die Reihe zu starten und zwei um die Reihe Fortzusetzten.  Es werden auch wieder Variablen benötigt, um das Spiel laufen zu lassen. Wie die Level anzahl, die Fehleranzahl die Anzahl an leveln und die Maximale größte Zahl. Für die Reihe und die Lösungen werden zwei Arrays deklariert. Diese bekommen die größe Fünf. Die Szene benötigt zwei Objekte für die Buttons und die Objekte für das Feuerwerk. In dieser Szene wurden anfangs, die Objekte für die Eingaben des Kinder und die Textfelder Einzelnd deklariert, in der aktuellsten Umsetzung wurden auch dafür zwei Arrays deklariert. Diese sind Public und somit können die einzelnen Objekte in Unity in das Skript von Hand eingefügt werden. Wie dies abläuft, ist in Abbildung 5.19 zu sehen.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs Start-Funktion}]
	void Start() {
		menu.onClick.AddListener(() => GoBack());
		lvlNumber = MenuPickLevelAdvanced.lvlAmmountStatic;
		maxNumbers = MenuPickLevelAdvanced.maxNumberStatic;
		checkSolution.interactable = false;
		checkSolution.onClick.AddListener(() => clickButton());
		for (int i = 0; i < arrayInputs.Length; i++){
			arrayInputs[i].onValueChanged.AddListener(delegate { EnableButton(); });
		}
		PlayGame();
	}
\end{lstlisting}
In der \textit{Start}-Funktion werden die Listener für die Buttons deklariert. Die größt mögliche Nummer die Zufällig erzeugt werden kann wird festgelegt und die Anzahl an leveln wird auch festgelegt. Der Test Button wird Deaktiviert. Um eine andere Art der Überprüfung ob ein Eingabefeld leer ist zu verwenden, wurde jedem der Eingabefelder über die Methode \textit{onValueChanged} ein Listener hinzugefügt. Diese Art ist zwar schon bekannt wurde in diesem Teil des Projektes aber noch nicht mit einem Array aus Objekten verwendet. Als letztes wurde die Funktion die das Spiel startet und immer wieder neu erzeugt aufgerufen, die \textit{PlayGame}-Funktion.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs EnableButton-Funktion}]
	public void EnableButton() {
		if (string.IsNullOrEmpty(arrayInputs[0].text) || string.IsNullOrEmpty(arrayInputs[1].text) || string.IsNullOrEmpty(arrayInputs[2].text) || string.IsNullOrEmpty(arrayInputs[3].text) || string.IsNullOrEmpty(arrayInputs[4].text)) {
			checkSolution.interactable = false;
		} else {
			checkSolution.interactable = true;
		}
	}
\end{lstlisting}
Hier ist die Funktion zu sehen, die den Testbutton Aktiviert oder Deaktiviert. Da es mehrer Felder sind, können diese entweder mithilfe einer \textit{For}-Schleife abgefragt werden, diese würde dann durch alle Eingabefelder iterieren und überprüfen ob an dieser stelle eine Eingabe ist, wenn ja könnte nach der gesamten überprüfung der Testbutton aktiviert werden, wenn nicht dann würde dieser Deaktiviert bleiben. Da es aber mit der Schleife mehr Code wäre, wurde in einem \textit{If}-Statement mithilfe der Oder-Verknüpfung überprüft ob eines der Felder leer ist. Wenn ja wird der Button nicht aktiviert oder erneut Deaktiviert, fals das Kind die Eingabe aus einem der Felder löscht. Wenn alle Felder gefüllt sind wird in einer \textit{else} der Button aktiviert.\\
Die nächsten vier Funktionen des Skriptes, werden nicht gezeigt, diese werden einmal aufgerufen, wenn der Menü Knopf gedrückt wird und wenn der Test Knopf gedrückt wurde. Diese Laden die Menü szene und starten die Abfrage ob die Eingegebene Lösung des Kindes richtig ist. Die letzten zwei Funktionen sind für die zufällige Zahlen zuständig, die erste der beide, erzeugt eine Zufällige Zahl zwischen null und der maximal möglichen Zahl. Die andere wird später zwei Mal aufgerufen um die Zahlen für das Muster zu erzeugen. Diese werden zwischen eins und der maximal möglichsten Zahl erzeugt. Der Grund dafür war, es wäre für die Kinder langweilig, wenn die Reihe sich um null erhöht. \\
\begin{lstlisting}[language=csh, caption={hideCircle.cs PlayGame-Funktion}]
	public void PlayGame() {
		lvlCounter++;
		if(lvlCounter > lvlNumber){
			PlayerPrefs.SetInt("wrongAnswers", wrongAnswers);
			SceneManager.LoadScene("LearnFinishScreen");
			Debug.Log("Game Vorbei \n" + "Anzahl Fehler: " + wrongAnswers);
		}
		ResetInputFields();
		if(lvlCounter <= lvlNumber)	lvlText.text = "Level: " + lvlCounter + "/" + lvlNumber;;
		randomNumber = RandomBeginningNumber(maxNumbers);
		FirstRandomNumber = RandomPatternNumbers();
		SecondRandomNumber = RandomPatternNumbers();
		SetStartPattern();
		SetSolution();
		SetPattern();
	}
\end{lstlisting}
Diese Funktion ist wieder ähnlich zu den anderne, sie überprüft wie viele Level noch gespielt werden müssen und beendet das Spiel oder setzt es fort. Wenn das Kind noch spielen soll, wird der Text um das Level anzuzeigen aktualisiert. Die eingabe Felder werden zurückgesetzt und die zufälligen Zahlen werden erzeugt und in die dazugehörige Variable gespeichert. Danach wird das Muster erzeugt und die darausfolgende Lösung berechnet. Als letztes wird das Muster nur noch in die Textfelder geschrieben.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs SetStartPattern- und SetSolution-Funktion}]
	public void SetStartPattern() {
		patternNumbers[0] = randomNumber;
		patternNumbers[1] = patternNumbers[0] + FirstRandomNumber;
		patternNumbers[2] = patternNumbers[1] + SecondRandomNumber;
		patternNumbers[3] = patternNumbers[2] + FirstRandomNumber;
		patternNumbers[4] = patternNumbers[3] + SecondRandomNumber;
	}

	public void SetSolution() {
		solutionsNumbers[0] = patternNumbers[4] + FirstRandomNumber;
		solutionsNumbers[1] = solutionsNumbers[0] + SecondRandomNumber;
		solutionsNumbers[2] = solutionsNumbers[1] + FirstRandomNumber;
		solutionsNumbers[3] = solutionsNumbers[2] + SecondRandomNumber;
		solutionsNumbers[4] = solutionsNumbers[3] + FirstRandomNumber;
	}
\end{lstlisting}
Diese Funktionen könnten auch in einer funktion stattfinden, wurde aber für die Übersichtlichkeit in zwei unterschiedlichen Implementiert. Die \textit{SetStartPattern}-Funktion, speichert an die erste stelle die Start Zahl ein. Danach wird mithilfe der zwei andern Zufallszahlen hier \textit{FirstRandomNumber} und \textit{SecondRandomNumber} genannt berechnet. Zuerst wird die erste Zahl darauf addiert, danach die zweite und so weiter. Nachdem das Muster berechnet wurde wird die Funktion \textit{SetSolution} aufgerufen, diese brechenet die Lösung die das Kind eintippen sollte. Dafür wird die letzte Zahl des Musters verwendet, auf diese wird die erste Zufallszahl addiert und danach auf das Ergebnis die zweite Zahl addiert. Das wird solange wiederholt, bis das Array gefüllt ist.\\
\begin{lstlisting}[language=csh, caption={hideCircle.cs SetPattern-Funktion}]
	public void SetPattern() {
		for (int i = 0; i < arrayInputs.Length; i++){
			arrayTextFields[i].text = patternNumbers[i].ToString();
		}
	}
\end{lstlisting}
Diese Funktion iteriert mit einer \textit{For}-Schleife durch das Textfeld Array und weißt jedem der Felder die passende Nummer zu. Die Integerzahl wird auch hier wieder in einen String umgewandelt.\\
Die Funktionen um das Feuerwerk zu erzeugen und zu löschen, sind die selben wie in dem Skript für die Rechenmauer.\\ %TODO nenne wo diese stehen
\begin{lstlisting}[language=csh, caption={hideCircle.cs Solution-Funktion}]
	IEnumerator Solution(int sec){
		bool skip = false;
		if (lvlCounter <= lvlNumber) {
			for (int i = 0; i < 5; i++) {
				if (solutionsNumbers[i] == int.Parse(arrayInputs[i].text)) {
					arrayInputs[i].interactable = false;
					continue;
				}
				else{
					skip = true;
					wrongAnswers++;
					arrayInputs[i].text = "";
				}
			}
			if (!skip) {
				SpawnFirework();
				yield return new WaitForSeconds(sec);
				DeleteFirework();
				PlayGame();
			}
		}
	}
\end{lstlisting}
Diese Funktion überprüft die Lösungen des Kindes. Dafür wird eine Boolean Variable benötigt. Danach wird mit einer \textit{For}-Schleife durch fünf Schritte Iteriert. Da die Arrays eine feste größe besitzen ist es möglich dort die fünf fest vorzugeben. In diesem Fall kann auch die Größe des eingabearrays oder des lösungsarrays verwendet werden. In der Schleife, werden die Eingaben des Schülers/der Schülerinn mit denen aus dem Lösungsarray verglichen, sobald eine Zahl gleich ist, wird die Boolean Variable auf true gesetzt und die schleife springt eine Iteration weiter. Wenn eine Eingabe nicht mit der Lösung übereinstimmt, wird die Boolean Variable auf true gesetzt und der Zähler für die Fehler wird um eins erhöht. Das dazugehörige Eingabefeld wird geleert, somit sollte das Kind wissen, das dieses Feld nicht richtig gelöst war. Wenn die Variable \textit{skipt} am ende der Schleife den wert false hat, sind alle Eingabefelder richtig gelöst. Daraufhin wird mithilfe der Funktion \textit{SpawnFirework} das Feuerwerk für den Nutzer erzeugt. Nach einer Sekunde wird dieses durch die Funktion \textit{DeleteFirework} wieder gelöscht. Als letzter Schritt des Skriptes wird die Funktion \textit{PlayGame} aufgerufen. \\
\begin{lstlisting}[language=csh, caption={hideCircle.cs ResetInputFields-Funktion}]
	public void ResetInputFields(){
		for (int i = 0; i < arrayInputs.Length; i++){
			arrayInputs[i].text = "";
			arrayInputs[i].interactable = true;
		}
	}
\end{lstlisting}
Diese Funktion löscht nach erfolgreichen Lösens der Reihe die eingabe aus alle Eingabefeldern. Das wird mit einer \textit{For}-Schleife gelöst. Diese leert das Eingabefeld und aktiviert es für den Nutzer wieder.
\subsection{Szene - Wortsalat}
\subsubsection{Wortsalat - Design}
\subsubsection{Wortsalat - Skript}
%TODO json file auch zeigen und erklären
\subsection{Szene - Nach Abschluss des Levels}
\subsubsection{Nach Abschluss des Levels - Design}
\subsubsection{Nach Abschluss des Levels - Skript}
\subsection{Speichern und Laden der Sterne}
